\section{Automi a Stati Finiti}

\subsection{Automa a Stati Finiti Deterministico (DFA)}
Un automa a stati finiti deterministico (DFA) è definito formalmente come una quintupla $A = (Q, \Sigma, \delta, q_0, F)$:
\begin{itemize}
    \item $Q$: un insieme finito di stati.
    \item $\Sigma$: un insieme finito di simboli di input (l'alfabeto).
    \item $\delta$: la funzione di transizione, definita come $\delta: (Q \times \Sigma) \rightarrow Q$. Per una coppia (stato, simbolo) restituisce un singolo stato di arrivo (es. $\delta(q_i, a) = q_j$).
    \item $q_0 \in Q$: lo stato iniziale.
    \item $F \subseteq Q$: l'insieme degli stati finali o di accettazione.
\end{itemize}

\subsection{Linguaggio Accettato e Configurazione}
Il linguaggio accettato da un automa A, denotato con $L(A)$, è l'insieme di tutte le stringhe $w$ che vengono accettate dall'automa.
\[ L(A) = \{ w \in \Sigma^* \mid w \text{ è accettata da A} \} \]
Una \textbf{configurazione istantanea} descrive lo stato dell'automa in un dato momento e consiste in una coppia `[stato attuale, stringa ancora da leggere]`.
\begin{itemize}
    \item Esempio: $[q_i, aw] \rightarrow [q_j, w]$ se $\delta(q_i, a) = q_j$.
\end{itemize}

\subsection{Esempio Pratico: Riconoscimento di "11"}
Consideriamo un automa che riconosce stringhe sull'alfabeto $\{0, 1\}$ che contengono due '1' consecutivi.
\begin{itemize}
    \item $Q = \{q_0, q_1, q_2\}$
    \item $\Sigma = \{0, 1\}$
    \item $q_0$ è lo stato iniziale.
    \item $F = \{q_2\}$
    \item La funzione di transizione $\delta$ è definita dalla seguente tabella:
\end{itemize}

\begin{center}
\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Stato} & \textbf{0} & \textbf{1} \\
    \hline
    $q_0$ & $q_0$ & $q_1$ \\
    \hline
    $q_1$ & $q_0$ & $q_2$ \\
    \hline
    $q_2$ & $q_2$ & $q_2$ \\
    \hline
\end{tabular}
\end{center}

\textbf{Computazione per la stringa $w = 10110$:}
\[ [q_0, 10110] \rightarrow [q_1, 0110] \rightarrow [q_0, 110] \rightarrow [q_1, 10] \rightarrow [q_2, 0] \rightarrow [q_2, \epsilon] \]
Poiché l'automa termina nello stato $q_2$, che è uno stato finale, la stringa $w=10110$ è accettata.

\begin{center}
    \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, on grid, auto]
        % Stati
        \node[state, initial] (q0) {$q_0$};
        \node[state] (q1) [right=of q0] {$q_1$};
        \node[state, accepting, double] (q2) [right=of q1] {$q_2$};
      
        % Transizioni
        \path[->]
          (q0) edge [loop above] node {0} ()
          (q0) edge node {1} (q1)
          (q1) edge [bend left] node {0} (q0)
          (q1) edge node {1} (q2)
          (q2) edge [loop above] node {0,1} ();
      \end{tikzpicture} 
    \end{center}
    
    \subsection{Esempio Pratico: Riconoscimento di tre a consecutive: "aaa"}
    \begin{center}
    \begin{tikzpicture}[shorten >=1pt, node distance=2.2cm, on grid, auto]
        \node[state, initial] (S1) {S};
        \node[state] (A1) [right=of S1] {A};
        \node[state] (B1) [right=of A1] {B};
        \node[state, accepting, double] (C1) [right=of B1] {C};
      
        \path[->]
          (S1) edge [loop above] node {b} ()
               edge node {a} (A1)
               edge [bend left=55] node {b} (B1)
          (A1) edge node {a} (B1)
               edge [bend left=55] node {b} (S1)
          (B1) edge node {a} (C1)
          (C1) edge [loop right] node {a,b} ();
      \end{tikzpicture}
    \end{center}
      
    \subsection{Esempio Pratico: Riconoscimento di tre a non consecutive: "aaa"}
      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=2.2cm, on grid, auto]
        \node[state, initial, accepting, double] (S2) {S};
        \node[state, accepting, double] (A2) [right=of S2] {A};
        \node[state, accepting, double] (B2) [right=of A2] {B};
        \node[state] (C2) [right=of B2] {C};
      
        \path[->]
          (S2) edge [loop above] node {b} ()
               edge node {a} (A2)
               edge [bend left=55] node {b} (B2)
          (A2) edge node {a} (B2)
               edge [bend left=55] node {b} (S2)
          (B2) edge node {a} (C2)
          (C2) edge [loop right] node {a,b} ();
      \end{tikzpicture}
    \end{center}
    
    \subsection{Complemento di un Linguaggio}
    \textbf{Teorema:} Se $A = (Q, \Sigma, \delta, q_0, F)$ è un DFA che accetta il linguaggio $L(A)$, allora l'automa $A' = (Q, \Sigma, \delta, q_0, Q-F)$ accetta il linguaggio complemento $\Sigma^* - L(A)$.
    \begin{itemize}
        \item In pratica, per ottenere un automa che accetta il linguaggio complemento, è sufficiente scambiare gli stati finali con quelli non finali.
    \end{itemize}
    
    \subsection{Esempio: Riconoscimento di Stringhe con numero di a  Pari}
    Consideriamo un automa per riconoscere il linguaggio delle stringhe su $\{a,b\}$ con un numero pari di 'a' e un numero pari di 'b'.
    \\
    \begin{minipage}{0.45\textwidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
             & $|w|_a$ & $|w|_b$ \\
        \hline
         S & pari    & pari    \\
        \hline
         A & dispari & pari    \\
        \hline
         B & pari    & dispari \\
        \hline
         C & dispari & dispari \\
        \hline
        \end{tabular}
        \end{minipage}%
        \hfill
        \begin{minipage}{0.52\textwidth}
        \centering
        \begin{tikzpicture}[node distance=2cm, on grid, auto]
          \node[state, initial, accepting, double] (S) {S};
          \node[state] (A) [above right=of S] {A};
          \node[state] (B) [below right=of S] {B};
          \node[state] (C) [right=of B] {C};
        
          \path[->] 
          (S) edge [bend left] node {a} (A)
              edge [bend right] node [swap] {b} (B)
          (A) edge [bend left] node {a} (S)
              edge node {b} (C)
          (B) edge [bend right] node [swap] {a} (C)
              edge [bend right] node [swap] {b} (S)
          (C) edge node {b} (A)
              edge [bend right] node [swap] {a} (B);
        \end{tikzpicture}
        \end{minipage}

\vspace{900pt}

        \subsection{Altri Esempi di DFA}
        %--- Esempio 1: stringa che non inizia con "aaa"
        \textbf{Esempio:} stringa che non inizia con \texttt{aaa}
        
        \begin{tikzpicture}[node distance=2cm, auto]
          \node[state, initial, accepting, double] (S) {S};
          \node[state] (A) [right=of S] {A};
          \node[state] (B) [below=of A] {B};
          \node[state] (C) [left=of B] {C};
          \node[state] (D) [right=of B] {D};
        
          \path[->]
            (S) edge node{a} (A)
                edge [bend left] node{b} (C)
            (A) edge [bend left] node{b} (C)
                edge node{a} (B)
            (C) edge [loop below] node{a,b} ()
                edge node{b} (B)
            (B) edge node{a} (D)
                edge [bend left] node{b} (C)
            (D) edge [loop right] node{a,b} ();
        \end{tikzpicture}
        
        \vspace{1em}
        
        %--- Esempio 2: stringa che contiene "aba"
        \textbf{Esempio:} stringa che contiene \texttt{aba}
        
        \begin{tikzpicture}[node distance=2cm, auto]
          \node[state, initial] (S2) {S};
          \node[state] (A2) [right=of S2] {A};
          \node[state] (B2) [right=of A2] {B};
          \node[state, accepting, double] (C2) [right=of B2] {C};
        
          \path[->]
            (S2) edge node{a} (A2)
                 edge [loop above] node{b} (S2)
            (A2) edge [loop above] node{a} ()
                 edge node{b} (B2)
            (B2) edge node{a} (C2)
                 edge [bend left=40] node{b} (S2)
            (C2) edge [loop above] node{b} ();
        \end{tikzpicture}
        
        \vspace{1em}
        
        %--- Esempio 3: ogni a preceduta o seguita da b
        \textbf{Esempio:} ogni \texttt{a} è preceduta o seguita da \texttt{b}
        
        \begin{tikzpicture}[node distance=2cm, auto]
          \node[state, initial, accepting, double] (S3) {S};
          \node[state] (A3) [right=of S3] {A};
          \node[state, accepting, double] (B3) [below=of S3] {B};
          \node[state] (C3) [right=of A3] {C};
        
          \path[->]
            (S3) edge [loop above] node{b} ()
                 edge node{a} (A3)
                 edge [bend left] node{a} (B3)
            (A3) edge node{a} (C3)
            (B3) edge [loop left] node{b} ()
                 edge node{a} (S3)
            (C3) edge [loop right] node{a,b} ();
        \end{tikzpicture}
        
        \vspace{1em}
        
        %--- Esempio 4: il numero di a e b è pari
        \textbf{Esempio:} il numero di \texttt{a} e di \texttt{b} è pari
        
        \begin{minipage}{0.4\textwidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
             & $|w|_a$ & $|w|_b$ \\
        \hline
         S & pari    & pari    \\
        \hline
         A & dispari & pari    \\
        \hline
         B & pari    & dispari \\
        \hline
         C & dispari & dispari \\
        \hline
        \end{tabular}
        \end{minipage}%
        \hfill
        \begin{minipage}{0.58\textwidth}
        \centering
        \begin{tikzpicture}[node distance=2cm, on grid, auto]
          \node[state, initial, accepting, double] (S4) {S};
          \node[state] (A4) [above right=of S4] {A};
          \node[state] (B4) [below right=of S4] {B};
          \node[state] (C4) [right=of B4] {C};
        
          \path[->]
            (S4) edge node{a} (A4)
                 edge node [swap]{b} (B4)
            (A4) edge [bend left] node{a} (S4)
                 edge node{b} (C4)
            (B4) edge node{a} (C4)
                 edge [bend left] node{b} (S4)
            (C4) edge [bend left] node{a} (B4)
                 edge [bend left] node{b} (A4);
        \end{tikzpicture}
        \end{minipage}
        
\subsubsection{Funzione di Transizione per NFA}
\[ \delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow 2^Q \]
Questo significa che per uno stato in $Q$ e un simbolo (o $\epsilon$), la funzione restituisce un \textit{insieme} di possibili stati successivi (indicato da $2^Q$, l'insieme delle parti di Q). 

\subsection{Automi a stati Finiti Non-Deterministici (NFA)}

Un \textbf{automa non-deterministico a stati finiti} (NFA) è la quintupla
\(A=(S,\Sigma,\delta,s_0,F)\) con:
\begin{enumerate}
  \item un insieme finito di stati \(S\);
  \item un insieme di simboli d'ingresso \(\Sigma\) (alfabeto); si assume che la stringa nulla \(\varepsilon\) non sia in \(\Sigma\);
  \item una funzione di transizione \(\delta : S \times (\Sigma \cup \{\varepsilon\}) \to 2^{S}\) che restituisce, per stato e simbolo, un insieme di stati successivi;
  \item uno stato \(s_0 \in S\) (\emph{stato iniziale});
  \item un sottoinsieme \(F \subseteq S\) (\emph{stati di accettazione}).
\end{enumerate}
\vspace{16pt}
Sia NFA che DFA si rappresentano con un \emph{grafo di transizione}: nodi = stati, archi etichettati = transizioni; esiste un arco etichettato \(a\) da \(s\) a \(t\) se e solo se \(t \in \delta(s,a)\).
Per gli NFA valgono queste particolarità:
\begin{enumerate}
  \item uno stesso simbolo può etichettare più archi uscenti dallo stesso stato verso stati diversi;
  \item un arco può essere etichettato con la stringa vuota \(\varepsilon\), da sola o insieme ad altri simboli dell’alfabeto.
\end{enumerate}

% Automa NFA per (a|b)*abb
\begin{center}
    \begin{tikzpicture}[node distance=2cm, auto]
      \node[state, initial] (0) {0};
      \node[state] (1) [right=of 0] {1};
      \node[state] (2) [right=of 1] {2};
      \node[state, accepting, double] (3) [right=of 2] {3};
      \path[->]
        (0) edge [loop above] node {a,b} ()
            edge node {a} (1)
        (1) edge node {b} (2)
        (2) edge node {b} (3);
    \end{tikzpicture}
    \\
    \footnotesize Figura 3.19 \quad Un automa finito non-deterministico che accetta \((a|b)^*abb\).
    \end{center}
    
    Secondo la nostra convenzione per i diagrammi di transizione, il doppio cerchio dello stato 3 indica che si tratta di uno stato finale, cioè uno stato d'accettazione. Si noti che l'unico modo per arrivare dallo stato 0 allo stato 3 richiede di seguire un percorso che rimane per un po' nello stato 0, poi passa attraverso lo stato 1, poi il 2 e infine 3, leggendo \texttt{abb} dalla sequenza d'ingresso. In altre parole, le uniche stringhe che consentono di arrivare allo stato finale sono quelle che terminano per \texttt{abb}.
    
    \subsubsection{Tabelle di transizione}
    Gli NFA sono descritti dalla seguente formula:
    \[\delta : Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^{Q}\]
    Possiamo rappresentare un NFA anche mediante una tabella di transizione, le cui righe corrispondono agli stati e le cui colonne indicano i simboli d'ingresso, più la stringa nulla $\varepsilon$. La casella corrispondente a un dato stato e un dato simbolo d'ingresso indica il valore assunto dalla funzione di transizione.
    
    \begin{center}
    \begin{tabular}{c|c|c|c}
    \textbf{Stato} & \textbf{a} & \textbf{b} & $\varepsilon$ \\
    \hline
    0 & $\{0,1\}$ & $\{0\}$ & $\varnothing$ \\
    1 & $\varnothing$ & $\{2\}$ & $\varnothing$ \\
    2 & $\varnothing$ & $\{3\}$ & $\varnothing$ \\
    3 & $\varnothing$ & $\varnothing$ & $\varnothing$ \\
    \end{tabular}
    \\
    \footnotesize Figura 3.20 \quad Tabella di transizione per l'NFA della Figura 3.19.
    \end{center}
    
    %arrivato a pagina n.132 (libro-it)

\subsection{Logica di simulazione di un NFA}

L'algoritmo per simulare un NFA verifica se una stringa in ingresso viene accettata calcolando iterativamente l'insieme degli stati raggiungibili.

\begin{verbatim}
S = epsilon_closure(s0)
c = nextChar()
while (c != eof) {
    S = epsilon_closure(move(S, c))
    c = nextChar()
}
if (intersezione(S, F) != vuoto) return "sì"
else return "no"
\end{verbatim}

\subsection{Costruzione di un NFA da espressioni regolari}
Per la \textbf{costruzione di un NFA da espressioni regolari} si utilizzano i seguenti scheletri fondamentali:

\begin{itemize}
  \item \textbf{Unione} ($r = s \mid t$):  
    Si crea un nuovo stato iniziale che, tramite transizioni $\varepsilon$, si collega sia al punto di ingresso dell'NFA per $s$ sia a quello per $t$. Gli stati finali dei due rami sono poi connessi tramite $\varepsilon$ a un unico nuovo stato finale comune.
    
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=1.5cm, on grid, auto]
        % Stati Start e Finale
        \node (start) {start};
        \node[state] (i) [right=of start] {i};
        \node[state, accepting] (f) [right=6cm of i] {f};
     
        % Blocchi ovali per N(s) e N(t)
        \draw (3, 1.5) ellipse (2.5cm and 0.8cm) node {$N(s)$};
        \draw (3, -1.5) ellipse (2.5cm and 0.8cm) node {$N(t)$};
     
        % Stati interni fittizi per i collegamenti
        \node[state, minimum size=0.6cm] (s_in) at (1.5, 1.5) {};
        \node[state, minimum size=0.6cm] (s_out) at (4.5, 1.5) {};
        \node[state, minimum size=0.6cm] (t_in) at (1.5, -1.5) {};
        \node[state, minimum size=0.6cm] (t_out) at (4.5, -1.5) {};
     
        % Frecce
        \path[->] (start) edge (i);
        \path[->] 
         (i) edge node {$\varepsilon$} (s_in)
         (i) edge node [swap] {$\varepsilon$} (t_in)
         (s_out) edge node {$\varepsilon$} (f)
         (t_out) edge node [swap] {$\varepsilon$} (f);
     \end{tikzpicture}
    \end{center}
  
  \item \textbf{Concatenazione} ($r = st$):  
    I due NFA per $s$ e $t$ vengono “collegati in serie”: lo stato finale di $s$ viene collegato tramite una transizione $\varepsilon$ allo stato iniziale di $t$.
    
    \begin{center}
    \begin{tikzpicture}[node distance=1.6cm, auto]
      \node[state, initial] (i) {i};
      \node[state] (s) [right=of i] {};
      \node[state] (t) [right=of s] {};
      \node[state, accepting, double, right=of t] (f) {f};
      \path[->]
        (i) edge (s)
        (s) edge node[above] {$\varepsilon$} (t)
        (t) edge (f);
    \end{tikzpicture}
    \end{center}
  
  \item \textbf{Chiusura di Kleene} ($r = s^*$):  
    Si aggiungono un nuovo stato iniziale e uno finale. Dal nuovo iniziale si può andare con una $\varepsilon$ sia al nuovo finale (per accettare la stringa vuota), sia verso l'NFA di $s$. Dallo stato finale di $s$ partono due $\varepsilon$-transizioni, una che torna all'inizio di $s$ (per ripetizioni) e una che va al nuovo finale.
    
    % Schema 3: Chiusura di Kleene r = s^* (versione pulita)
    \begin{figure}[h]
      \centering
      \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
         
         % --- 1. Posizionamento dei Nodi ---
         
         % Nodo Start (etichetta)
         \node (start) {start};
         
         % Nuovo Stato Iniziale (i)
         \node[state] (i) [right=1.5cm of start] {i};
  
         % Stati interni fittizi per N(s) (distanziati maggiormente da i)
         % s_in è l'inizio del vecchio automa, s_out è la fine
         \node[state, minimum size=0.8cm] (s_in) [right=3cm of i] {}; 
         \node[state, minimum size=0.8cm] (s_out) [right=4cm of s_in] {};
  
         % Nuovo Stato Finale (f)
         \node[state, accepting] (f) [right=3cm of s_out] {f};
  
         % --- 2. Disegno dell'Ovale N(s) ---
         % Calcolo il centro tra s_in e s_out per disegnare l'ellisse
         \draw ($(s_in)!0.5!(s_out)$) ellipse (3cm and 1.2cm);
         \node at ($(s_in)!0.5!(s_out)$) {\Large $N(s)$};
  
         % --- 3. Frecce e Transizioni ---
         \path[->] 
          (start) edge (i)
          
          % Ingresso nel sotto-automa
          (i) edge node {$\varepsilon$} (s_in)
          
          % Uscita dal sotto-automa
          (s_out) edge node {$\varepsilon$} (f)
          
          % Loop indietro (Ripetizione): da fine s a inizio s
          (s_out) edge [bend right=60] node [swap] {$\varepsilon$} (s_in)
          
          % Salto in avanti (Stringa vuota/Zero occorrenze): da i a f
          (i) edge [bend right=50] node [swap] {$\varepsilon$} (f);
  
      \end{tikzpicture}
  \end{figure}
\end{itemize}


\subsection*{Costruzione step-by-step di un NFA per \((a|b)^*abb\)}

% NFA per la lettera 'a' (prima parte)
\textbf{a:}\quad
\begin{tikzpicture}[baseline=-0.5ex,node distance=1.8cm, 
    every state/.style={minimum size=16pt}, auto]
  \node[state, initial] (q2) {2};
  \node[state, accepting, double] (q3) [right=of q2] {3};
  \path[->]
    (q2) edge node {a} (q3);
\end{tikzpicture}
\qquad
% NFA per la lettera 'b' (seconda parte)
\textbf{b:}\quad
\begin{tikzpicture}[baseline=-0.5ex,node distance=1.8cm, 
    every state/.style={minimum size=16pt}, auto]
  \node[state, initial] (q4) {4};
  \node[state, accepting, double] (q5) [right=of q4] {5};
  \path[->]
    (q4) edge node {b} (q5);
\end{tikzpicture}


\begin{minipage}[c]{0.49\textwidth}
  \textbf{a|b:}
  
  \begin{tikzpicture}[node distance=1.7cm, on grid, auto]
    \node[state, initial] (q1) {1};
    \node[state] (q2) [above right=1.2cm and 1cm of q1] {2};
    \node[state] (q3) [right=of q2] {3};
    \node[state] (q4) [below right=1.2cm and 1cm of q1] {4};
    \node[state] (q5) [right=of q4] {5};
    \node[state, accepting, double] (q6) [right=3.8cm of q1] {6};
    \path[->]
      (q1) edge node[sloped, above] {$\varepsilon$} (q2)
           edge node[sloped, below] {$\varepsilon$} (q4)
      (q2) edge node {a} (q3)
      (q3) edge node[sloped, above] {$\varepsilon$} (q6)
      (q4) edge node {b} (q5)
      (q5) edge node[sloped, below] {$\varepsilon$} (q6);
    % Evidenziazione delle due sottosequenze (opzionale)
    \usetikzlibrary{calc}
    \draw[dashed, magenta, rounded corners=8pt] ($(q2)+(-0.3,0.5)$) rectangle ($(q3)+(0.3,-0.5)$);
    \draw[dashed, magenta, rounded corners=8pt] ($(q4)+(-0.3,-0.5)$) rectangle ($(q5)+(0.3,0.5)$);
  \end{tikzpicture}
  \end{minipage}
  \hfill
  \begin{minipage}[c]{0.49\textwidth}
    \textbf{(a|b)$^*$:}

    \begin{tikzpicture}[node distance=1.3cm, on grid, auto]
      % Stati
      \node[state, initial] (q0) {0};
      \node[state] (q1) [right=of q0] {1};
      \node[state] (q2) [above right=1.3cm and 1.1cm of q1] {2};
      \node[state] (q3) [right=of q2] {3};
      \node[state] (q4) [below right=1.3cm and 1.1cm of q1] {4};
      \node[state] (q5) [right=of q4] {5};
      \node[state] (q6) [right=4.0cm of q1] {6};
      \node[state, accepting, double] (q7) [right=of q6] {7};
    
      % Transizioni
      \path[->]
        (q0) edge node[above] {$\varepsilon$}(q1)
        (q1) edge[bend left=8] node[above] {$\varepsilon$} (q2)
        (q1) edge[bend right=8] node[below] {$\varepsilon$} (q4)
        (q2) edge node {a} (q3)
        (q3) edge[bend left=8] node[above] {$\varepsilon$} (q6)
        (q4) edge node {b} (q5)
        (q5) edge[bend right=8] node[below] {$\varepsilon$} (q6)
        (q6) edge[bend left=20] node[above] {$\varepsilon$} (q1)
        (q0) edge[bend left=30] node[below] {$\varepsilon$} (q7)
        (q6) edge[bend right=18] node[below] {$\varepsilon$} (q7);
    \end{tikzpicture}
    
  \end{minipage}
  
  \textbf{(a|b)$^*$a:}

\begin{tikzpicture}[node distance=1.7cm, on grid, auto]
  % Stati
  \node[state, initial] (q0) {0};
  \node[state] (q1) [right=of q0] {1};
  \node[state] (q2) [above right=1.2cm and 1cm of q1] {2};
  \node[state] (q3) [right=of q2] {3};
  \node[state] (q4) [below right=1.2cm and 1cm of q1] {4};
  \node[state] (q5) [right=of q4] {5};
  \node[state] (q6) [right=4.0cm of q1] {6};
  \node[state] (q7) [right=of q6] {7};
  \node[state, accepting, double] (q8) [right=of q7] {8};

  % Transizioni automa star
  \path[->]
    (q0) edge node[above] {$\varepsilon$} (q1)
    (q1) edge[bend left=12] node[above] {$\varepsilon$} (q2)
    (q1) edge[bend right=12] node[below] {$\varepsilon$} (q4)
    (q2) edge node {a} (q3)
    (q3) edge[bend left=12] node[above] {$\varepsilon$} (q6)
    (q4) edge node {b} (q5)
    (q0) edge[bend left=30] node[below] {$\varepsilon$} (q7)
    (q5) edge[bend right=12] node[below] {$\varepsilon$} (q6)
    (q6) edge[bend left=18] node[above] {$\varepsilon$} (q1);

  % Uscita dal blocco star verso nuovo stato per 'a'
  \path[->]
    (q6) edge node {$\varepsilon$} (q7)
    (q7) edge node {a} (q8);

\end{tikzpicture}


\textbf{(a|b)$^*$abb:}

\begin{tikzpicture}[node distance=1.7cm, on grid, auto]
  % Stati principali
  \node[state, initial] (q0) {0};
  \node[state] (q1) [right=of q0] {1};
  \node[state] (q2) [above right=1.2cm and 1cm of q1] {2};
  \node[state] (q3) [right=of q2] {3};
  \node[state] (q4) [below right=1.2cm and 1cm of q1] {4};
  \node[state] (q5) [right=of q4] {5};
  \node[state] (q6) [right=4.0cm of q1] {6};
  \node[state] (q7) [right=of q6] {7};
  \node[state] (q8) [right=of q7] {8};
  \node[state] (q9) [right=of q8] {9};
  \node[state, accepting, double] (q10) [right=of q9] {10};

  % Transizioni automa star
  \path[->]
    (q0) edge node[above] {$\varepsilon$} (q1)
    (q1) edge[bend left=12] node[above] {$\varepsilon$} (q2)
    (q1) edge[bend right=12] node[below] {$\varepsilon$} (q4)
    (q2) edge node {a} (q3)
    (q3) edge[bend left=12] node[above] {$\varepsilon$} (q6)
    (q4) edge node {b} (q5)
    (q0) edge[bend left=30] node[below] {$\varepsilon$} (q7)
    (q5) edge[bend right=12] node[below] {$\varepsilon$} (q6)
    (q6) edge[bend left=18] node[above] {$\varepsilon$} (q1);

  % Concatenazione abb finale
  \path[->]
    (q6) edge node {$\varepsilon$} (q7)
    (q7) edge node {a} (q8)
    (q8) edge node {b} (q9)
    (q9) edge node {b} (q10);
\end{tikzpicture}


\subsection{Convertire un NFA in un DFA}

L'idea generale alla base della \textbf{costruzione per sottoinsiemi} è che ogni stato del DFA costruito corrisponda a un \textit{insieme} di stati dell'NFA di partenza. Dopo aver letto una sequenza di input $a_1 a_2 \dots a_n$, il DFA si troverà nello stato che rappresenta l'insieme di tutti i possibili stati in cui l'NFA potrebbe trovarsi processando quella stessa sequenza.

Un aspetto positivo di questo approccio è che, per i linguaggi di interesse pratico, il numero di stati del DFA risultante è approssimativamente lo stesso dell'NFA, evitando l'esplosione esponenziale degli stati che teoricamente potrebbe verificarsi.

\subsubsection*{Funzioni di base}
Per gestire correttamente le $\varepsilon$-transizioni, definiamo le seguenti operazioni sugli stati dell'NFA:

\paragraph{$\varepsilon$-closure(s)}
L'insieme degli stati del NFA raggiungibili da uno stato $s$ seguendo solo percorsi di $\varepsilon$-transizioni (incluso $s$ stesso).
\begin{align*}
  \varepsilon\text{-cl}(6) &= \{6, 7, 1, 2, 4\} \\
  \varepsilon\text{-cl}(8) &= \{8\} \\
  \varepsilon\text{-cl}(0) &= \{0, 1, 2, 4, 7\}
\end{align*}

\paragraph{$\varepsilon$-closure(T)}
Estensione della funzione precedente a un insieme di stati $T$. È l'unione delle $\varepsilon$-closure di tutti gli stati in $T$:
\[
\varepsilon\text{-cl}(T) = \bigcup_{s \in T} \varepsilon\text{-cl}(s)
\]

\paragraph{move(T, a)}
L'insieme degli stati dell'NFA raggiungibili da un qualsiasi stato nell'insieme $T$ consumando il simbolo di input $a$.

\subsubsection*{Costruzione della Tabella di Transizione (Dtran)}
L'algoritmo costruisce gli stati del DFA ($A, B, C, \dots$) e la funzione di transizione \texttt{Dtran}. Lo stato iniziale del DFA è dato da $\varepsilon\text{-closure}(s_0)$, dove $s_0$ è lo stato iniziale dell'NFA.

Calcoliamo lo stato iniziale $A$:
\[
A = \varepsilon\text{-cl}(0) = \{0, 1, 2, 4, 7\}
\]

Ora calcoliamo le transizioni per i simboli di input (es. 'a' e 'b') partendo da $A$:
\begin{align*}
  \mathrm{Dtran}[A, a] &= \varepsilon\text{-cl}(\mathrm{move}(A, a))\\
        &= \varepsilon\text{-cl}(\{3, 8\}) = \{3, 6, 7, 1, 2, 4, 8\} = \{1, 2, 3, 4, 6, 7, 8\} = B \\
  \mathrm{Dtran}[A, b] &= \varepsilon\text{-cl}(\mathrm{move}(A, b))\\
        &= \varepsilon\text{-cl}(\{5\}) = \{1, 2, 4, 5, 6, 7\} = C 
\end{align*}

Avendo scoperto i nuovi stati $B$ e $C$, procediamo a calcolare le loro transizioni:
\begin{align*}
  \mathrm{Dtran}[B, a] &= \varepsilon\text{-cl}(\mathrm{move}(B, a))\\
        &= \varepsilon\text{-cl}(\{3, 8\}) = B
\end{align*}

L'algoritmo prosegue calcolando le transizioni per tutti gli stati scoperti finché non se ne trovano di nuovi. I passaggi rimanenti (omessi per brevità) sono:
\vspace{0.3cm}
\texttt{Dtran[B, b]},\quad \texttt{Dtran[C, a]},\quad \texttt{Dtran[C, b]},\quad \texttt{Dtran[D, a]},\quad \texttt{Dtran[D, b]}

\subsubsection*{Risultato Finale}
Gli stati di accettazione del DFA sono tutti quegli insiemi che contengono almeno uno stato di accettazione dell'NFA originale.

\vspace{0.5cm}
\begin{minipage}{0.45\textwidth}
  \textbf{Tabella delle transizioni DFA}
  
  \begin{tabular}{c|c|c}
   & a & b \\
  \hline
  A & B & C \\
  B & B & D \\
  C & B & E \\
  D & B & D \\
  E & B & C \\
  \end{tabular}
\end{minipage}
\hfill
\begin{minipage}{0.52\textwidth}
  \textbf{Schema DFA}
  
  \begin{tikzpicture}[node distance=1.8cm, auto]
    \node[state, initial] (A) {A};
    \node[state] (B) [right=of A] {B};
    \node[state] (C) [below=of B] {C};
    \node[state] (D) [right=of B] {D};
    \node[state, accepting, double] (E) [below=of D] {E};
  
    % Archi delle transizioni
    \path[->]
      (A) edge[bend left] node {a} (B)
      (A) edge[bend right] node {b} (C)
      (B) edge[loop above] node {a} ()
      (B) edge node {b} (D)
      (C) edge node {a} (B)
      (C) edge[bend right] node {b} (E)
      (D) edge[loop above] node {b} ()
      (D) edge node {a} (B);
  \end{tikzpicture}
\end{minipage}
\subsection{Minimizzazione dei DFA}

L'algoritmo di minimizzazione degli stati si basa sul partizionamento degli stati del DFA in gruppi di stati non distinguibili. Ogni gruppo viene infine fuso in un unico stato del nuovo DFA minimo.

\subsubsection{Concetti Fondamentali}
\begin{itemize}
    \item Data una stringa $x$, si dice che $x$ \textbf{distingue} due stati se, partendo da questi stati e seguendo le transizioni etichettate da $x$, si arriva esattamente in uno stato di accettazione e nell'altro in uno stato non accettante.
    \item Uno stato $A$ è \textbf{distinguibile} da uno stato $B$ se esiste almeno una stringa che li distingue.
    \item Due stati $A$ e $B$ sono \textbf{equivalenti} (o non distinguibili) se nessuna stringa li distingue. In un DFA minimo, stati equivalenti vengono fusi insieme.
\end{itemize}

\subsubsection{Algoritmo}
Si parte da una partizione iniziale $\Pi = \{F, S-F\}$ che separa stati finali da stati non finali. Si raffina la partizione iterativamente finché non è più possibile suddividere i gruppi.
Due stati $s, t$ rimangono nello stesso gruppo se e solo se per ogni simbolo di input $a$, le transizioni $\delta(s, a)$ e $\delta(t, a)$ portano a stati che appartengono allo stesso gruppo nella partizione corrente.

\subsubsection{Esempio Pratico}
Consideriamo il seguente automa (modificato per rendere A e C equivalenti):

\begin{center}
\begin{tikzpicture}[node distance=2.5cm, auto, >=stealth]
    \node[state, initial] (A) {A};
    \node[state] (B) [right=of A] {B};
    \node[state] (C) [above=of B] {C};
    \node[state] (D) [right=of B] {D};
    \node[state, accepting, double] (E) [right=of D] {E};
  
    % Transizioni
    \path[->]
      (A) edge node {a} (B)
          edge [bend left=40] node {b} (E) % A va in E con b (come C)
      (B) edge node {b} (D)
          edge [loop below] node {a} ()
      (C) edge node {a} (B) % C va in B con a (come A)
          edge node {b} (E) % C va in E con b (come A)
      (D) edge [bend left=20] node {b} (E)
          edge [loop above] node {a} ()
      (E) edge [loop right] node {b} ();
\end{tikzpicture}
\end{center}

\textbf{Passi della Minimizzazione:}
\begin{enumerate}
    \item \textbf{Partizione Iniziale:} Separazione tra finali e non finali.
    \[ \Pi_0 = \{ \{A, B, C, D\}, \{E\} \} \]
    
    \item \textbf{Raffinamento 1:} Analizziamo il gruppo $\{A, B, C, D\}$ con l'input 'b'.
    \begin{itemize}
        \item $A \xrightarrow{b} E$ (gruppo 2)
        \item $C \xrightarrow{b} E$ (gruppo 2)
        \item $D \xrightarrow{b} E$ (gruppo 2)
        \item $B \xrightarrow{b} D$ (gruppo 1) $\rightarrow$ \textbf{B si comporta diversamente!}
    \end{itemize}
    Nuova partizione:
    \[ \Pi_1 = \{ \{A, C, D\}, \{B\}, \{E\} \} \]

    \item \textbf{Raffinamento 2:} Analizziamo il gruppo $\{A, C, D\}$ con l'input 'a'.
    \begin{itemize}
        \item $A \xrightarrow{a} B$ (gruppo B)
        \item $C \xrightarrow{a} B$ (gruppo B)
        \item $D \xrightarrow{a} D$ (gruppo A,C,D) $\rightarrow$ \textbf{D si comporta diversamente!}
    \end{itemize}
    Nuova partizione:
    \[ \Pi_2 = \{ \{A, C\}, \{B\}, \{D\}, \{E\} \} \]
    
    \item \textbf{Verifica Finale:} A e C sono equivalenti?
    \begin{itemize}
        \item Con 'a' vanno entrambi in B.
        \item Con 'b' vanno entrambi in E.
    \end{itemize}
    Sì, sono indistinguibili. L'algoritmo termina.
\end{enumerate}

\textbf{Automa Minimo Finale:}
Lo stato iniziale è $\{AC\}$ perché conteneva lo stato iniziale originale.

\begin{center}
  \begin{tikzpicture}[auto, >=stealth, node distance=2.5cm]
    \node[state, initial] (AC) {AC};
    \node[state] (B) [right=of AC] {B};
    \node[state] (D) [right=of B] {D};
    \node[state, accepting, double] (E) [below=of D] {E};
  
    \path[->]
        (AC) edge node {a} (B)
             edge [bend right=20] node {b} (E)
        (B)  edge [loop above] node {a} ()
             edge node {b} (D)
        (D)  edge [loop above] node {a} ()
             edge node {b} (E)
        (E)  edge [loop right] node {b} ();
  \end{tikzpicture}
\end{center}
  
