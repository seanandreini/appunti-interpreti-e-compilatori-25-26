\section{Traduzione guidata dalla sintassi}

Associando attributi ai simboli grammaticali, si definiscono valori tramite regole semantiche. La traduzione guidata dalla sintassi costruisce un albero di parsing per calcolare questi valori.

\subsection{Definizioni guidate dalla sintassi (SSD)}

È una grammatica context-free con l'aggiunta di attributi e regole semantiche. Gli attributi sono associati ai simboli della grammatica, le regole semantiche sono associate alle produzioni.

\textbf{Osservazione:} Dato un simbolo della grammatica \(X\) e uno dei suoi attributi \(a\), si indica \(X.a\) (il valore di a per uno specifico nodo dell'albero di parsing con etichetta X).

Una SSD che contiene solo attributi sintetizzati è detta \textbf{S-attribuita}, cioè dove ogni regola calcola un attributo associato alla variabile della parte sinistra della produzione mediante gli attributi associati ai simboli della parte destra. Una SSD senza effetti collaterali (qualcosa che modifica lo stato del sistema oltre a restituire un valore, tipo stampare a video) è detta \textbf{grammatica ad attributi}.

\subsection{Valutazione di una SSD ai nodi di un albero di parsing}

Un albero di parsing annotato mostra i valori degli attributi associati ai nodi.

Gli attributi ereditati sono utili quando la struttura dell'albero di parsing non corrisponde alla sintassi astratta del codice sorgente.

\subsubsection{Attributi sintetizzati}
Un attributo sintetizzato relativo ad un nodo \(N\) è definito unicamente in base ai figli di \(N\) e a \(N\) stesso.

\subsubsection{Attributi ereditati}
Un attributo ereditato relativo ad un nodo \(N\) è definito unicamente in base al padre di \(N\), a \(N\) stesso e ai fratelli di \(N\) (non dai figli).

\textbf{NB!} I terminali non possono avere attributi ereditati.

\subsection{Esempio: \(3 \times 5 \times 4\)}

\subsubsection{Prima grammatica}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to T * F\) \quad \(T.val = T.val \times F.val\)
    \item \(T \to F\) \quad \(T.val = F.val\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=2cm},
  level 3/.style={sibling distance=1.5cm}
]
\node {\(T.val =\)}
  child {node {\(T.val =\)}
    child {node {\(T.val\)}
      child {node {\(F.val\)}
        child {node {3}}
      }
    }
    child {node {*}}
    child {node {\(F.val\)}
      child {node {5}}
    }
  }
  child {node {*}}
  child {node {\(F.val\)}
    child {node {4}}
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, *, 5, *, 4

\subsubsection{Seconda grammatica (con attributi ereditati)}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to FT'\) \quad \(T'.inh = F.val\) \quad \(T.val = T'.syn\)
    \item \(T' \to *FT'_1\) \quad \(T'_1.inh = T'.inh \times F.val\) \quad \(T'.syn = T'_1.syn\)
    \item \(T' \to \varepsilon\) \quad \(T'.syn = T'.inh\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=2.2cm,
  level 1/.style={sibling distance=7cm},
  level 2/.style={sibling distance=4.5cm},
  level 3/.style={sibling distance=3.5cm},
  level 4/.style={sibling distance=2.5cm},
  every node/.style={align=center, text width=4.5cm, font=\small}
]
\node {\(T.val = T'.syn(60)\)}
  child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(3)\)}
    child {node[text width=1cm] {3}}
  }
  child {node[text width=4cm] {\(T'.inh = F.val(3)\) \\ \(T'.syn = T'_1.syn(60)\)}
    child {node[text width=1cm] {*}}
    child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(5)\)}
      child {node[text width=1cm] {5}}
    }
    child {node[text width=4.5cm] {\(T'_1.inh =\) \\ \(T'.inh \times F.val(15)\) \\ \(T'_1.syn = T'_2.syn(60)\)}
      child {node[text width=1cm] {*}}
      child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(4)\)}
        child {node[text width=1cm] {4}}
      }
      child {node[text width=4.5cm] {\(T'_2.inh =\) \\ \(T'_1.inh \times F.val(60)\) \\ \(T'_2.syn = T'_2.inh(60)\)}
        child {node[text width=1.5cm] {\(\varepsilon\)}}
      }
    }
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, 5, *, 4, \(\varepsilon\)

\textbf{Calcolo dei valori:}
\begin{itemize}
    \item \(F.val = 3\)
    \item \(T'.inh = 3\)
    \item \(F.val = 5\)
    \item \(T'_1.inh = 3 \times 5 = 15\)
    \item \(F.val = 4\)
    \item \(T'_2.inh = 15 \times 4 = 60\)
    \item \(T'_2.syn = 60\)
    \item \(T'_1.syn = 60\)
    \item \(T'.syn = 60\)
    \item \(T.val = 60\)
\end{itemize}



\subsection{Grafi delle dipendenze}

\subsubsection{Esempio: \(1 * 2\)}

\textbf{Produzioni e regole semantiche:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzione} & \textbf{Regole semantiche} \\
\hline
1) \(T \to FT'\) & \(T'.inh = F.val\) \\
 & \(T.val = T'.syn\) \\
\hline
2) \(T' \to * F T'_1\) & \(T'_1.inh = T'.inh \times F.val\) \\
 & \(T'.syn = T'_1.syn\) \\
\hline
3) \(T' \to \varepsilon\) & \(T'.syn = T'.inh\) \\
\hline
4) \(F \to \text{digit}\) & \(F.val = \text{digit}.lexval\) \\
\hline
\end{tabular}
\end{center}

\textbf{Grafo delle dipendenze:}

\begin{center}
\begin{tikzpicture}[
  node distance=1.5cm and 2cm,
  every node/.style={font=\footnotesize},
  arrow/.style={->, thick, >=stealth, dashed}
]

% Nodi disposti secondo l'immagine
\node (T9val) at (2,5) {\(T\) 9 \(val\)};
\node (F3val) at (-2,3.5) {\(F\) 3 \(val\)};
\node (inh5) at (2,3.5) {\(inh\) 5 \(T'\)};
\node (syn8) at (5,3.5) {8 \(syn\) \(T'\)};
\node (digit1) at (-2,2) {digit 1 \(lexval\)};
\node (star) at (0,2) {*};
\node (F4val) at (2,1.5) {\(F\) 4 \(val\)};
\node (inh6) at (4.5,1.5) {\(inh\) 6 \(T'\)};
\node (syn7) at (6.5,1.5) {7 \(syn\) \(T'\)};
\node (digit2) at (2,0) {digit 2 \(lexval\)};
\node (epsilon) at (4.5,0) {\(\varepsilon\)};

% Frecce come nell'immagine
% digit 1 -> F 3 val
\draw[arrow] (digit1) -- (F3val);

% F 3 val -> inh 5 T'
\draw[arrow] (F3val) to[out=0, in=180] (inh5);

% digit 2 -> F 4 val
\draw[arrow] (digit2) -- (F4val);

% F 4 val -> inh 6 T'
\draw[arrow] (F4val) -- (inh6);

% inh 5 T' -> inh 6 T' (curva)
\draw[arrow] (inh5) to[out=-20, in=150] (inh6);

% inh 6 T' -> syn 7 T' (arco sopra)
\draw[arrow] (inh6) to[out=60, in=120] (syn7);

% syn 7 T' -> syn 8 T'
\draw[arrow] (syn7) to[out=150, in=0] (syn8);

% syn 8 T' -> T 9 val (curva a destra)
\draw[arrow] (syn8) to[out=90, in=0] (T9val);

\end{tikzpicture}
\end{center}


\subsection{Ordinamento topologico}

Gli ordinamenti validi sono costituiti da sequenze \(N_1, N_2, \ldots, N_k\), tale che se esiste un arco dal nodo \(N_i\) al nodo \(N_j\) nel grafo delle dipendenze, allora deve essere \(i < j\).

\subsection{Grammatiche S-attribuite}

Una definizione guidata dalla sintassi è S-attribuita se e solo se ogni suo attributo è sintetizzato.

\subsection{Grammatiche L-attribuite}

Una definizione è L-attribuita se, nel grafo delle dipendenze, gli archi vanno solo da sinistra a destra. In particolare:
\begin{itemize}
    \item Gli attributi ereditati possono dipendere solo da attributi (ereditati o sintetizzati) dei simboli alla loro \textbf{sinistra} o da attributi ereditati del padre.
    \item Questo vincolo è necessario per evitare cicli e permettere la valutazione in una sola passata.
\end{itemize}

\paragraph{Effetti Controllati}
Non sempre le pure regole semantiche bastano. Spesso si introducono \textbf{effetti controllati} (es. \texttt{print}, aggiornamento della Symbol Table).
\begin{itemize}
    \item Questi effetti sono permessi in modo che la traduzione risulti corretta per qualsiasi ordinamento di valutazione valido.
    \item I vincoli di ordine imposti dagli effetti laterali vengono trattati come \textbf{archi impliciti} nel grafo delle dipendenze.
\end{itemize}

\subsection{Alberi sintattici}
È utile trasformare una stringa in ingresso in un albero che ne rappresenta la struttura gerarchica (albero sintattico) per facilitare le fasi successive della compilazione.

\subsection{Classi di SDT implementabili durante il parsing}
Esistono due classi principali di SDT che consentono l'implementazione della traduzione direttamente durante l'analisi sintattica:

\begin{enumerate}
    \item La grammatica sottostante può essere riconosciuta da un parser \textbf{LR} e la SDD è \textbf{S-attribuita} (approccio \textit{bottom-up}).
    \item La grammatica sottostante può essere riconosciuta da un parser \textbf{LL} e la SDD è \textbf{L-attribuita} (approccio \textit{top-down}).
\end{enumerate}

\subsubsection{Marcatori e proprietà}
Per gestire azioni semantiche in posizioni arbitrarie, si possono introdurre dei marcatori (non-terminali che producono $\epsilon$).

\textbf{Proprietà:} Se la grammatica arricchita con i marcatori può essere trattata da un dato metodo di parsing, allora lo SDT corrispondente può essere implementato durante il parsing stesso.

\subsection{SDT postfissi}
Un SDT si dice \textbf{postfisso} se, in ogni produzione, le azioni semantiche sono posizionate esclusivamente \textbf{alla fine} del corpo della produzione.
\[ A \to X Y Z \{ \text{azione} \} \]
Questi schemi sono ideali per l'implementazione durante il parsing bottom-up.
\subsubsection{Schema di traduzione postfisso - Calcolatrice}

\textbf{Produzioni, Regole sintattiche e SDT:}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Produzioni} & \textbf{Regole sintattiche} & \textbf{SDT} \\
\hline
\(L \to E\) \textbf{n} & \{\texttt{print}(\(E.val\))\} & \{\texttt{print}(\(E.val\))\} \\
\hline
\(E \to E + T\) & \{\(E.val = E_1.val + T.val\)\} & \{\(E.val = E_1.val + T.val\)\} \\
\hline
\(E \to T\) & \{\(E.val = T.val\)\} & \{\(E.val = T.val\)\} \\
\hline
\(T \to T * F\) & \{\(T.val = T_1.val \times F.val\)\} & \{\(T.val = T_1.val \times F.val\)\} \\
\hline
\(T \to F\) & \{\(T.val = F.val\)\} & \{\(T.val = F.val\)\} \\
\hline
\(F \to (E)\) & \{\(F.val = E.val\)\} & \{\(F.val = E.val\)\} \\
\hline
\(F \to \textbf{digit}\) & \{\(F.val = \textbf{digit}.lexval\)\} & \{\(F.val = \textbf{digit}.lexval\)\} \\
\hline
\end{tabular}
\end{center}

\subsection{Stack del parser con attributi}

\textbf{Rappresentazione dello stack:}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
 & \(XYZ\) & \\
\hline
 & \(X.x\) \(Y.y\) \(Z.z\) & \\
\hline
\multicolumn{3}{c}{\(\uparrow\)} \\
\multicolumn{3}{c}{top} \\
\end{tabular}
\end{center}

Dopo una riduzione \(A \to XYZ\):

\begin{center}
\begin{tabular}{|c|}
\hline
\(A\) \\
\hline
\(A.a\) \\
\hline
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}

Dove \(A.a = f(X.x, Y.y, Z.z)\)

\subsection{Implementazione con manipolazione dello stack}

\textbf{Azioni con manipolazione esplicita dello stack:}

\begin{itemize}
    \item \(L \to E\) \textbf{n}: \{\texttt{print}(\(stack[top-1].val\)); \(top = top - 1\)\}
    \item \(E \to E + T\): \{\(E.val = E.val + T.val\)\}
    \item \(T \to T * F\): \{\(stack[top-2].val = stack[top-2].val \times stack[top].val\); \(top = top - 2\)\}
    \item \(F \to (E)\): \{\(stack[top-2].val = stack[top-1].val\); \(top = top - 2\)\}
\end{itemize}

\subsection{Esempio di parsing: \(3 * (5 + 2)\) \textbf{n}}

\textbf{Sequenza di parsing con lo stack:}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
& \(F\) & \(E\) & \(T\) & \(E+T\) & \(T*F\) & (\(E\)) & & \\
\hline
& \(\uparrow\) & & & & & & & \\
\hline
3 & * & ( & 5 & + & 2 & ) & \textbf{n} & \texttt{print} \\
\hline
\end{tabular}
\end{center}

\textbf{Evoluzione dello stack:}

\begin{itemize}
    \item Dopo applicazione di \(F \to (E)\): \(top\) viene decrementato
    \item Dopo riduzione: i valori vengono calcolati e memorizzati nella posizione corretta dello stack
\end{itemize}

\textbf{Posizioni dello stack durante il parsing:}

\begin{center}
\begin{tabular}{c}
top-2 \\
\(\uparrow\) \\
top-1 \\
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}





\subsection{Schemi di traduzione con azioni interne alle produzioni}

\subsubsection{Definizione e comportamento}

Un'azione può essere inserita in qualsiasi posizione nel corpo di una produzione. Essa sarà eseguita non appena tutti i simboli grammaticali alla sua sinistra saranno stati consumati.

Quindi, in una produzione del tipo \(B \to X \{a\} Y\), l'azione \(a\) è eseguita non appena abbiamo riconosciuto \(X\), se \(X\) è un terminale, oppure tutti i terminali derivati da \(X\), se quest'ultimo è un non-terminale.

\textbf{Comportamento nel parsing:}

\begin{itemize}
    \item Nel parsing \textbf{bottom-up}: si esegue l'azione \(a\) non appena l'occorrenza in esame del simbolo \(X\) appare sulla cima dello stack
    \item Nel parsing \textbf{top-down}: si esegue l'azione \(a\) immediatamente prima di tentare l'espansione di \(Y\), se \(Y\) è un non-terminale, oppure prima di cercare \(Y\) in ingresso, se \(Y\) è un terminale
\end{itemize}

\subsection{Eliminazione della ricorsione sinistra dagli SDT}

\subsubsection{Motivazione e principi}

Poiché nessuna grammatica che presenti ricorsione sinistra può essere analizzata mediante parsing top-down, diventa fondamentale eliminare tale tipo di ricorsione.

Quando una grammatica è L-attribuita e la si trasforma per eliminare la ricorsione sinistra, dobbiamo gestire correttamente le azioni semantiche.

\textbf{Assunzione:} Le azioni semantiche non calcolano valori di attributi ma effettuano azioni sulle stringhe di simboli terminali.

\textbf{Principio:} Nel processo di trasformazione della grammatica, le azioni semantiche sono trattate come ulteriori simboli terminali.

\subsubsection{Trasformazione standard}

Le trasformazioni della grammatica preservano l'ordine dei terminali nella stringa generata. La strategia consiste nel sostituire produzioni della forma:
\[
A \to A\alpha \mid \beta
\]
con nuove produzioni usando un nuovo non-terminale \(R\):
\[
A \to \beta R
\]
\[
R \to \alpha R \mid \varepsilon
\]

\subsubsection{Trasformazione per SDD S-attribuite}

Per una singola produzione ricorsiva, una singola produzione non-ricorsiva, ed un singolo attributo del non-terminale ricorsivo sinistro.

\textbf{Grammatica originale con ricorsione sinistra:}

\begin{itemize}
    \item \(A \to A\alpha\) con azione \(\{A.a = g(A_1.a, \alpha.y)\}\)
    \item \(A \to X\) con azione \(\{A.a = f(X.x)\}\)
\end{itemize}

\textbf{Grammatica trasformata senza ricorsione sinistra:}

\begin{itemize}
    \item \(A \to X\) \(\{R.i = f(X.x)\}\) \(R\) \(\{A.a = R.s\}\)
    \item \(R \to \alpha\) \(\{R_1.i = g(R.i, \alpha.y)\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
\end{itemize}

Dove \(R.i\) è l'attributo ereditato e \(R.s\) è l'attributo sintetizzato di \(R\).

\subsubsection{Esempio - Eliminazione ricorsione nelle espressioni}

Si considerino le seguenti produzioni relative a \(E\), prese da uno SDT per la traduzione di espressioni dalla forma infissa alla forma postfissa.

\textbf{SDT con ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzioni} & \textbf{Azioni semantiche} \\
\hline
\(E \to E_1 + T\) & \(\{\text{print}('+');\}\) \\
\hline
\(E \to T\) & \\
\hline
\end{tabular}
\end{center}

\noindent Se applichiamo la trasformazione standard al non-terminale \(E\), identifichiamo le parti $\alpha$ (la parte ricorsiva) e $\beta$ (la base) trattando l'azione semantica come un simbolo terminale:

\begin{itemize}
    \item Il \textbf{resto della produzione ricorsiva sinistra} ($\alpha$) è:
    \[ \alpha = + T \; \{ \text{print}('+'); \} \]
    \item Il \textbf{corpo dell'altra produzione} ($\beta$) è:
    \[ \beta = T \]
\end{itemize}

Introducendo il nuovo non-terminale \(R\) (che rappresenta il resto), si applica la regola \(E \to \beta R\) e \(R \to \alpha R \mid \varepsilon\), ottenendo:

\textbf{SDT senza ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|}
\hline
\textbf{Produzioni risultanti} \\
\hline
\(E \to T R\) \\
\hline
\(R \to + T\) \(\{\text{print}('+');\}\) \(R\) \\
\hline
\(R \to \varepsilon\) \\
\hline
\end{tabular}
\end{center}

\subsubsection{Esempio completo - Calcolatrice da tavolo}

\textbf{Con ricorsione sinistra:}

\begin{itemize}
    \item \(E \to E_1 + T\) \(\{E.v = E_1.v + T.v\}\)
    \item \(E \to T\) \(\{E.v = T.v\}\)
    \item \(T \to T_1 \times F\) \(\{T.v = T_1.v \times F.v\}\)
    \item \(T \to F\) \(\{T.v = F.v\}\)
    \item \(F \to (E)\) \(\{F.v = E.v\}\)
    \item \(F \to \textbf{digit}\) \(\{F.v = \textbf{digit}.\text{lexval}\}\)
\end{itemize}

\textbf{Senza ricorsione sinistra:}

\begin{itemize}
    \item \(E \to T\) \(\{R.i = T.v\}\) \(R\) \(\{E.v = R.s\}\)
    \item \(R \to + T\) \(\{R_1.i = R.i + T.v\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
    \item \(T \to F\) \(\{X.i = F.v\}\) \(X\) \(\{T.v = X.s\}\)
    \item \(X \to \times F\) \(\{X_1.i = X.i \times F.v\}\) \(X_1\) \(\{X.s = X_1.s\}\)
    \item \(X \to \varepsilon\) \(\{X.s = X.i\}\)
\end{itemize}

\subsection{Procedure generali per SDT}

\subsubsection{Procedura in tre passi}

\begin{enumerate}
    \item Si costruisce l'albero di parsing, ignorando le azioni semantiche
    \item Si esamina ogni nodo interno \(N\) con produzione associata. Si aggiungono nuovi nodi figli di \(N\) corrispondenti alle azioni, in modo che scorrendo tutti i figli di \(N\) da sinistra a destra si abbiano esattamente gli stessi simboli e le stesse azioni semantiche
    \item Si visita l'albero in preordine e non appena si incontra un nodo annotato con un'azione la si esegue
\end{enumerate}

\subsubsection{Esempio con albero di parsing}

Per l'espressione \(3 \times 5 + 4\), l'output in notazione prefissa è: \(+ (\times 3 \ 5) \ 4\)

Le azioni \(\{\text{print}('+');\}\) e \(\{\text{print}('*');\}\) vengono eseguite visitando l'albero in preordine, stampando gli operatori prima degli operandi.


L'albero rappresenta il parsing dell'espressione \(3 \times 5 + 4\) con le azioni di stampa in notazione prefissa.

\begin{center}
\begin{tikzpicture}[
  level distance=1.6cm,
  level 1/.style={sibling distance=5cm},
  level 2/.style={sibling distance=3.5cm},
  level 3/.style={sibling distance=2.8cm},
  level 4/.style={sibling distance=2cm},
  level 5/.style={sibling distance=1.5cm},
  every node/.style={align=center, font=\small},
  action/.style={fill=yellow!40, rectangle, rounded corners, inner sep=3pt, font=\footnotesize}
]

\node (L) {\(L\)}
  child {node (E1) {\(E\)}
    child {node (E2) {\(E\)}
      child {node (T1) {\(T\)}
        child {node (T2) {\(T\)}
          child {node (F1) {\(F\)}
            child {node (d1) {digit}
              child {node[action] (a3) {\{\text{print}(3);\}}}
            }
          }
        }
        child {node (star) {*}}
        child {node (F2) {\(F\)}
          child {node (d2) {digit}
            child {node[action] (a5) {\{\text{print}(5);\}}}
          }
        }
      }
      child {node (plus) {+}}
      child {node (T3) {\(T\)}
        child {node (F3) {\(F\)}
          child {node (d3) {digit}
            child {node[action] (a4) {\{\text{print}(4);\}}}
          }
        }
      }
    }
    child {node (n) {\textbf{n}}}
  };

% Azioni semantiche con linee tratteggiate
\node[action, left=2cm of E2] (print_plus) {\{\text{print}('+');\}};
\node[action, left=2cm of T2] (print_star) {\{\text{print}('*');\}};

% Linee tratteggiate che collegano le azioni ai nodi
\draw[dashed, gray, thick] (print_plus) -- (E2);
\draw[dashed, gray, thick] (print_star) -- (T1);

\end{tikzpicture}
\end{center}

\textbf{Output in notazione prefissa:} + * 3 5 4

\textbf{Ordine di esecuzione delle azioni:}
\begin{enumerate}
    \item print('+')
    \item print('*')
    \item print(3)
    \item print(5)
    \item print(4)
\end{enumerate}

%lezione 20 novembre
\subsection{Trasformazione da SDD L-attribuita a SDT}
Regole per trasformare SDD $\to$ SDT per parsing Top-Down:

\begin{enumerate}
    \item \textbf{Azioni per Attributi Ereditati:} Si aggiungono le azioni che calcolano gli attributi ereditati di un non-terminale $A$ \textbf{immediatamente prima} dell'occorrenza di $A$ nel corpo della produzione.
    \item \textbf{Azioni per Attributi Sintetizzati:} Si aggiungono le azioni che calcolano un attributo sintetizzato relativo alla testa della produzione \textbf{alla fine} del corpo di quella produzione.
\end{enumerate}

\section*{Esempio: Traduzione dello Statement \texttt{while}}
Consideriamo la produzione:
\[ S \to \mathbf{while} \ (C) \ S_1 \]

Useremo i seguenti attributi per generare il codice intermedio richiesto:

\begin{enumerate}
    \item L'attributo \textbf{ereditato} $S.next$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito dopo che $S$ è terminato.
    
    \item L'attributo \textbf{sintetizzato} $S.code$ è la porzione di codice intermedio che implementa uno statement $S$ e termina con un salto a $S.next$ (se necessario, o cade nel flusso successivo).
    
    \item L'attributo \textbf{ereditato} $C.true$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito se $C$ risulta vera.
    
    \item L'attributo \textbf{ereditato} $C.false$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito se $C$ risulta falsa.
    
    \item L'attributo \textbf{sintetizzato} $C.code$ rappresenta la porzione di codice intermedio che implementa la condizione $C$ e che salta a $C.true$ oppure $C.false$ a seconda del valore dell'espressione $C$.
\end{enumerate}

\subsection*{Regole Semantiche (SDD)}
Per generare le nuove etichette e definire il flusso, si applicano le seguenti regole:

\begin{align*}
& L1 = \text{new}(); \quad \text{(Genera etichetta inizio ciclo)} \\
& L2 = \text{new}(); \quad \text{(Genera etichetta inizio corpo)} \\
& S_1.next = L1; \quad \text{(Dopo il corpo, torna a valutare la condizione)} \\
& C.false = S.next; \quad \text{(Se falso, esce dal ciclo)} \\
& C.true = L2; \quad \text{(Se vero, esegue il corpo)} \\
& S.code = \textbf{label} \ || \ L1 \ || \ C.code \ || \ \textbf{label} \ || \ L2 \ || \ S_1.code
\end{align*}

\subsection*{Logica del Flusso di Controllo}
Il funzionamento del codice generato segue questo schema logico (rappresentazione del diagramma):

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[
      node distance=3.5cm, % Aumentata la distanza orizzontale
      box/.style={
          draw, 
          minimum width=1.5cm, 
          minimum height=1cm, 
          align=center, 
          font=\large\bfseries
      },
      arrow/.style={
          ->, 
          >=Stealth, 
          thick,
          rounded corners=5pt
      }
  ]

  % --- 1. DEFINIZIONE DEI NODI ---
  
  % Nodo C (Condizione)
  \node[box] (C) {C};
  
  % Nodo S1 (Statement) - Posizionato più lontano per leggibilità
  \node[box, right=of C] (S1) {S\textsubscript{1}};

  % --- 2. COORDINATE PER IL BOX ESTERNO (S) ---
  % Calcolo coordinate per fare il rettangolo arancione grande abbastanza
  \coordinate (TopLeft) at ($(C.north west) + (-2, 2.5)$);
  \coordinate (BottomRight) at ($(S1.south east) + (2, -2)$);
  \coordinate (ExitPoint) at ($(BottomRight) + (0, 0.5)$); % Punto di uscita fittizio a destra

  % Disegno il box S (sfondo)
  \draw[orange!80!yellow, thick] (TopLeft) rectangle (BottomRight);
  
  % Etichetta grande "S" (spostata in basso a sinistra per non disturbare)
  \node[font=\Huge\bfseries\sffamily, orange!40!yellow, anchor=south west] 
      at ($(TopLeft |- BottomRight) + (0.2, 0.2)$) {S};

  % --- 3. FRECCE E FLUSSO ---

  % Ingresso L
  \draw[arrow, black] ($(C.west) - (1.5, 0)$) -- node[above] {L\textsubscript{1}} (C.west);
  \draw[arrow, orange!80!yellow, thick] ($(TopLeft |- C) + (-1, 0.5)$) -- node[above, black] {L} ($(TopLeft |- C) + (0.5, 0.5)$);

  % Percorso TRUE (Centrale)
  \draw[arrow, cyan, thick] (C.east) -- 
      node[above, text=black, yshift=2pt] {TRUE} 
      node[below, text=black] {L\textsubscript{2}} 
      (S1.west);
  
  % Nota sopra il percorso True
  \node[font=\small\sffamily, align=center] at ($(C)!0.5!(S1) + (0, 0.8)$) {Eseguo 1\textdegree{} istruzione};

  % Percorso LOOP (Ritorno da S1 a C) - Alto
  \draw[arrow, cyan, thick] (S1.north) -- ++(0, 1) coordinate(midup)
      -- ($(C.north) + (0, 1)$) 
      node[midway, above, text width=5cm, align=center, black] {Devo rifare controllo\\condizione} 
      -- (C.north);

  % Percorso FALSE (Uscita) - Basso
  \draw[arrow, green!60!black, thick] (C.south) 
      to[out=-90, in=180] ($(S1.south) + (0, -1)$) 
      -- (ExitPoint |- S1.south) 
      -- ++(1,0) node[right, black] {NEXT};
      
  \node[below right, font=\small] at (C.south east) {FALSE};

  \end{tikzpicture}
  \caption{Flusso di controllo del ciclo While.}
\end{figure}

\textbf{Spiegazione del diagramma:}
\begin{itemize}
    \item Il flusso entra nell'etichetta $L1$ (inizio del \texttt{while}).
    \item Viene valutata la condizione $C$.
    \item Se $C$ è \textbf{TRUE}, si va all'etichetta $L2$, si esegue lo statement $S_1$ e, al termine di $S_1$, il flusso deve tornare indietro a $L1$ per rivalutare la condizione.
    \item Se $C$ è \textbf{FALSE}, il flusso salta direttamente all'uscita ($S.next$ o NEXT).
\end{itemize}

\subsection*{Schema di Traduzione (SDT)}
Inserendo le azioni semantiche all'interno della produzione per supportare la generazione durante il parsing (anche top-down), otteniamo:

\begin{verbatim}
S -> while (
    { L1 = new(); L2 = new(); C.false = S.next; C.true = L2; }
    C )
    { S1.next = L1; }
    S1
    { S.code = label || L1 || C.code || label || L2 || S1.code; }
\end{verbatim}

In questo modo, le etichette $L1$ e $L2$ vengono generate prima di analizzare la condizione, e l'attributo $S_1.next$ viene impostato correttamente prima di analizzare il corpo $S_1$.

\subsection{Implementazione di SDD L-attribute}

I seguenti sono metodi che realizzano la traduzione durante la visita di un albero di parsing

\begin{itemize}
    \item \textbf{Traduzione durante la visita di un albero di parsing:}
    \begin{enumerate}
        \item Costruzione di un albero di parsing annotato (funziona per qualsiasi SDD non circolare).
        \item Costruzione dell'albero, aggiunta delle azioni e loro esecuzione in pre-ordine.
    \end{enumerate}
    \textit{Nota:} Questo approcci hanno un costo computazionale elevato (costruzione dell'albero).

    \item \textbf{Metodi di traduzione durante il parsing:}
    \begin{enumerate}
        \item Utilizzo di un parser a discesa ricorsiva con una funzione per ogni non-terminale.
        \item Generazione del codice al volo (On-the-fly), utilizzando un parser a discesa ricorsiva.
        \item Implementazione di uno SDT insieme a un parser LL.
        \item Implementazione di uno SDT insieme a un parser LR.
    \end{enumerate}
\end{itemize}

\subsubsection{Traduzione durante il parsing a discesa ricorsiva}
Un parser a discesa ricorsiva prevede una funzione A() per ogni non-terminale A della grammatica. È possibile estendere un tale parser
e trasformarlo in un traduttore facendo in modo che:
\begin{itemize}
    \item Gli argomenti della funzione $A()$ siano gli \textbf{attributi ereditati} del simbolo non-terminale $A$.
    \item Il valore restituito da $A()$ sia l'insieme degli \textbf{attributi sintetizzati} del simbolo $A$.
\end{itemize}

Il corpo della funzione deve occuparsi sia del parsing che della gestione degli attributi, in particolare la funzione deve:
\begin{enumerate}
    \item Decidere quale produzione utilizzare per espandere $A$.
    \item Verificare che ogni simbolo terminale appaia in ingresso quando richiesto; in quanto segue assumeremo che non sia necessario effettuare backtracking.
    \item Conservare in variabili locali i valori degli attributi necessari per il calcolo degli attributi ereditati relativi ai non-terminali nel corpo della produzione e/o
    degli attributi ereditati relativi al non-terminale alla testa della produzione.
    \item Chiamare le funzioni corrispondenti ai non-terminali nel corpo della produzione, passando gli argomenti corretti (ereditati) e salvando i risultati (sintetizzati).
\end{enumerate}

\subsubsection{Esempio: Implementazione \texttt{while} con ritorno di stringa}
\begin{lstlisting}[caption={Pseudocodice per la traduzione del while}]
  string S(label next) {
      string Scode, Ccode; /* variabili locali per frammenti di codice */
      label L1, L2;        /* etichette locali */
        
      if (il simbolo_corrente è il token WHILE) {
        
          avanza il puntatore di ingresso;
            
          verifica che '(' sia il prossimo simbolo, quindi avanza;
            
          L1 = new(); // Etichetta inizio controllo condizione
          L2 = new(); // Etichetta inizio corpo del ciclo
            
          Ccode = C(next, L2); 
            
          verifica che ')' sia il prossimo simbolo, quindi avanza;
            
          Scode = S(L1); 
            
          // Costruzione dell'attributo sintetizzato finale
          return ("label" || L1 || Ccode || "label" || L2 || Scode);
      }
      else { 
          /* gestione altri tipi di statement */ 
      }
  }
  \end{lstlisting}

  \subsection{Esempio Pratico: Parser a Discesa Ricorsiva per Espressioni}
  Di seguito è riportato il codice (pseudocodice C-like) per un parser che gestisce espressioni aritmetiche con eliminazione della ricorsione sinistra e gestione degli attributi.
  
  \textbf{Grammatica di riferimento (dopo eliminazione ricorsione sinistra):}
  \begin{align*}
  E &\to T \{ R.i = T.v \} R \{ E.v = R.s \} \\
  R &\to + T \{ R_1.i = R.i + T.v \} R_1 \{ R.s = R_1.s \} \mid \epsilon \{ R.s = R.i \} \\
  T &\to F \{ X.i = F.v \} X \{ T.v = X.s \} \\
  X &\to * F \{ X_1.i = X.i * F.v \} X_1 \{ X.s = X_1.s \} \mid \epsilon \{ X.s = X.i \} \\
  F &\to ( E ) \{ F.v = E.v \} \mid d \{ F.v = d.lexval \}
  \end{align*}
  
  \textbf{Implementazione delle funzioni:}
  
  \begin{lstlisting}
  // Gestione Produzione E -> T R
  int E() {
      int v_i, ev;
      // FIRST(T R) include FIRST(F) = { (, d }
      if (lookahead in { '(', 'd' }) {
          v_i = T();       // Calcola T.val
          ev = R(v_i);     // Passa T.val come ereditato a R
          return ev;       // Ritorna attributo sintetizzato
      } else {
          error();
      }
  }
  
  // Gestione Produzione T -> F X
  int T() {
      int x_i, tv;
      if (lookahead in { '(', 'd' }) {
          x_i = F();       // Calcola F.val
          tv = X(x_i);     // Passa F.val come ereditato a X
          return tv;
      } else {
          error();
      }
  }
  
  // Gestione Produzione R -> + T R1 | epsilon
  int R(int v_i) {
      int v_if, vs, tv;
      if (lookahead == '+') {
          match('+');
          tv = T();           // Calcola valore del termine successivo
          v_if = v_i + tv;    // Calcola nuovo ereditato: somma parziale
          vs = R(v_if);       // Ricorsione
          return vs;
      } 
      // Gestione produzione epsilon (FOLLOW(R) include ')', '$')
      else if (lookahead in { ')', '$' }) {
          return v_i;         // Ritorna il valore accumulato finora
      } else {
          error();
      }
  }
  
  // Gestione Produzione X -> * F X1 | epsilon
  int X(int x_i) {
      int x_1i, xs, fv;
      if (lookahead == '*') {
          match('*');
          fv = F();           // Calcola valore del fattore
          x_1i = x_i * fv;    // Calcola nuovo ereditato: prodotto parziale
          xs = X(x_1i);       // Ricorsione
          return xs;
      }
      // Gestione produzione epsilon (FOLLOW(X) include '+', ')', '$')
      else if (lookahead in { '+', ')', '$' }) {
          return x_i;
      } else {
          error();
      }
  }
  
  // Gestione Produzione F -> ( E ) | d
  int F() {
      int fv;
      if (lookahead == '(') {
          match('(');
          fv = E();
          match(')');
          return fv;
      } 
      else if (lookahead == 'd') {
          fv = lexval; // Valore del numero
          match('d');
          return fv;
      } else {
          error();
      }
  }
  \end{lstlisting}
  

  \subsubsection{Generazione del codice al volo}

  In molti casi comuni, tra cui il nostro esempio di generazione del codice del costrutto \texttt{while}, è possibile costruire incrementalmente porzioni di codice e memorizzarle in un array o in un file mediante opportune azioni dello SDT. Per fare ciò, le seguenti condizioni devono essere soddisfatte:
  
  \begin{enumerate}
      \item Per uno o più non-terminali esiste un attributo \textit{principale}. Per semplicità assumeremo che gli attributi principali siano tutti di tipo stringa.
      
      \item Gli attributi principali sono sintetizzati.
      
      \item Le regole per la valutazione degli attributi principali garantiscono che:
      \begin{enumerate}
          \item[(a)] l'attributo principale è dato dal concatenamento degli attributi principali dei non-terminali che appaiono nel corpo della produzione più, eventualmente, altri elementi che non sono attributi principali;
          
          \item[(b)] gli attributi principali dei non-terminali appaiono nella regola nello stesso ordine in cui i non-terminali appaiono nel corpo della produzione.
      \end{enumerate}
  \end{enumerate}
  
  Tali condizioni implicano che l'attributo principale può essere costruito emettendo solamente gli elementi del concatenamento che non sono attributi principali.

\subsubsection{Esempio: Statement While}
Possiamo modificare la funzione in modo che emetta gli elementi dell'attributo principale $S.code$ invece di salvarli per poi concatenarli nel valore di $S.code$ che verrà poi restituito.

Le funzioni $S()$ e $C()$ non restituiscono alcun valore, poiché tutti i loro attributi sintetizzati sono prodotti mediante stampa. Inoltre, la posizione delle istruzioni di stampa nella funzione è importante. L'ordine in cui i vari elementi vengono stampati è il seguente: per prima cosa la stringa ``label'' $L1$, quindi il codice relativo al non-terminale $C$, la stringa ``label'' $L2$, e infine il codice derivante dalla chiamata ricorsiva della funzione $S()$ .

\textbf{Codice con generazione al volo (pseudocodice):}

\begin{lstlisting}
void S(label next) {
    label L1, L2; /* etichette locali */
    if (simbolo_corrente è il token WHILE) {
        avanza il puntatore di ingresso;
        verifica che '(' sia il prossimo simbolo, quindi avanza;
        
        L1 = new(); 
        L2 = new();
        
        print("label", L1); // Stampa immediata
        
        // C gestisce i salti: true -> L2 (corpo), false -> next (uscita)
        C(next, L2); 
        
        verifica che '(' sia il prossimo simbolo, quindi avanza;
        
        print("label", L2); // Stampa etichetta corpo
        
        S(L1); // Chiamata ricorsiva per il corpo, torna a L1 dopo esec.
    }
    else { /* altri statement */ }
}
\end{lstlisting}

\subsection{Trasformazione SDD L-attribuita su grammatica LL a SDT azioni interne alle produzioni}
Supponiamo che una SDD L-attribuita sia basata su una grammatica LL e che sia stata convertita in uno SDT in cui le azioni si trovano all'interno delle produzioni. Possiamo effettuare la traduzione durante il parsing LL a patto di estendere lo stack del parser in modo da poter contenere \textbf{diversi tipi di record}.

Oltre ai record che rappresentano i terminali e i non-terminali della grammatica, lo stack del parser conterrà:
\begin{itemize}
    \item \textbf{action-record}: cioè record che contengono puntatori ad azioni che devono essere eseguite, e anche copie di attributi.
    \item \textbf{synthesize-record}: ovvero record destinati a salvare gli attributi sintetizzati dei non-terminali. Possono contenere azioni il cui scopo, in ordine, è copiare gli attributi sintetici più in basso nello stack in altri record.
\end{itemize}

Per gestire gli attributi sullo stack ci baseremo sui seguenti principi:

\begin{itemize}
    \item Gli attributi \textbf{ereditati} di un non-terminale $A$ sono memorizzati sullo stack, nel record che rappresenta il non-terminale. Il codice necessario per la valutazione di tali attributi è in genere rappresentato mediante un \textit{action-record} memorizzato sullo stack, immediatamente al di sopra del record che rappresenta $A$.
    
    \item Gli attributi \textbf{sintetizzati} relativi al non-terminale $A$ sono memorizzati in un \textit{synthesize-record} separato e posizionato sullo stack immediatamente al di sotto del record relativo ad $A$.
\end{itemize}


%lezione 24 novembre
\subsection{Implementazione SDT con un Parser LL}

Nel contesto dei parser LL, possiamo gestire la traduzione guidata dalla sintassi (SDT) inserendo le azioni semantiche all'interno delle produzioni.

\subsubsection{Esempio 1: Statement While}
Di seguito vengono mostrati due modi alternativi per implementare la traduzione dello statement \texttt{while}.

\subsubsection*{Generazione "al volo" (con print)}
In questo approccio, le etichette vengono stampate immediatamente non appena vengono generate o quando il parser raggiunge il punto corretto. Non si usa un attributo \texttt{S.code}.

\[
\begin{array}{rl}
S \to \textbf{while } ( & \{ L1 = new(); \ L2 = new(); \\
& C.false = S.next; \ C.true = L2; \\
& \textbf{print(``label'', L1);} \} \\
C \ ) & \{ S_1.next = L1; \\
& \textbf{print(``label'', L2);} \} \\
S_1 & 
\end{array}
\]

\subsubsection*{Costruzione Attributi Sintetizzati}
In questo approccio, il codice non viene stampato subito, ma viene concatenato in un'unica stringa (\texttt{S.code}) alla fine della produzione. È il metodo più generale.

\[
\begin{array}{rl}
S \to \textbf{while } ( & \{ L1 = new(); \ L2 = new(); \\
& C.false = S.next; \ C.true = L2; \} \\
C \ ) & \{ S_1.next = L1; \} \\
S_1 & \{ \textbf{$S.code =$ label} \ || \ L1 \ || \ C.code \ || \ \textbf{label} \ || \ L2 \ || \ S_1.code; \}
\end{array}
\]

\subsubsection*{Proprietà Invarianti}
Si suppone valida un'ipotesi induttiva riguardo alla gestione dello stack:
\begin{itemize}
    \item Ogni Non-Terminale (NT) a cui è associato del codice, lascia tale codice memorizzato sotto forma di stringa nel \textbf{Synthesize-record} posizionato immediatamente al di sotto del NT nello stack.
\end{itemize}

\noindent\textbf{Spiegazione della gestione dello Stack:}

La figura seguente illustra illustra la gestione dello stack per la traduzione dello statement \texttt{while} basata sulla produzione e sulle azioni semantiche definite. Il processo si articola nelle seguenti fasi:

\begin{enumerate}
    \item \textbf{Situazione Iniziale (Fig. a):} 
    Sulla cima dello stack si trova il record per il non-terminale $S$ (con l'attributo ereditato $S.next$). Immediatamente sotto c'è il \textit{synthesize-record} di $S$, destinato a contenere il codice finale generato ($S.code$).

    \item \textbf{Espansione e Azione Iniziale:}
    Il simbolo $S$ viene espanso. Dopo aver consumato i token \textbf{while} e \textbf{(}, viene eseguito il codice dell'\textit{action-record}:
    \begin{itemize}
        \item Vengono generate le nuove etichette $L1$ e $L2$.
        \item Le etichette vengono assegnate agli attributi ereditati necessari ($C.true$ e $C.false$).
        \item I valori di $L1$ e $L2$ vengono copiati nel \textit{synthesize-record} di $S_1$ per essere usati alla fine.
    \end{itemize}

    \item \textbf{Elaborazione della Condizione $C$:}
    Per ipotesi induttiva, $C$ calcola il proprio codice intermedio e lo salva nell'attributo sintetizzato $C.code$. Una volta rimosso $C$ dallo stack, il suo \textit{synthesize-record} copia questo valore nel campo $Ccode$ del record sottostante (quello di $S_1$).

    \item \textbf{Elaborazione del Corpo $S_1$:}
    Dopo aver consumato la parentesi chiusa \textbf{)}, viene elaborato $S_1$. Anche qui, per ipotesi induttiva, il codice del corpo viene generato e salvato nel campo $code$ del \textit{synthesize-record} di $S_1$.

    \item \textbf{Sintesi Finale:}
    Quando il \textit{synthesize-record} di $S_1$ arriva in cima allo stack, contiene tutti i pezzi necessari ($L1, L2, Ccode, code$). L'azione finale concatena queste parti nel giusto ordine:
    \[ \text{label } L1 \ || \ Ccode \ || \ \text{label } L2 \ || \ code \]
    La stringa risultante viene salvata nel \textit{synthesize-record} di $S$ (che si trova sotto), completando la traduzione.
\end{enumerate}


\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
      node distance=0.2cm,
      % Stili per i blocchi
      header/.style={rectangle, draw, minimum width=1.4cm, minimum height=0.6cm, align=center, font=\small},
      body/.style={rectangle, draw, minimum width=1.4cm, align=left, font=\scriptsize, inner sep=3pt},
      codeblock/.style={rectangle, draw, align=left, font=\scriptsize\ttfamily, inner sep=4pt},
      pinkbox/.style={rectangle, draw=magenta, thick, align=left, font=\scriptsize\ttfamily, inner sep=3pt},
      note/.style={font=\footnotesize\itshape, align=left, text width=2.5cm, fill=white, inner sep=1pt}, % Sfondo bianco
      cross/.style={text=violet, font=\bfseries\Large} % Crocette più visibili
  ]

  % --- FIGURA (a) ---
  \node (top_a) at (0, 1.5) {top};
  \draw[->] (top_a) -- (0, 0.9);
  
  \node[header] (S_head) at (0, 0.5) {$S$};
  \node[body, below=0cm of S_head] (S_body) {$next=x$};
  
  \node[header, right=0.3cm of S_head] (SynthS_head) {Synthesize\\$S.code$};
  \node[body, below=0cm of SynthS_head] (SynthS_body) {$code=?$\\data};
  \node[below=0.2cm of SynthS_body, font=\scriptsize] {actions};
  


  % --- FIGURA (b) ---
  % Sposto tutto più in basso e a destra per dare spazio alle note laterali
  \coordinate (start_b) at (-3, -3.5);
  \node (top_b) at (-3, -2.5) {top};
  \draw[->] (top_b) -- (start_b);
  
  % Blocchi dello stack (distanziati orizzontalmente)
  \node[header, font=\bfseries] (while) at (start_b) {while};
  \node[header, minimum width=0.6cm, right=0.3cm of while] (open) {(};
  
  \node[header, right=0.3cm of open] (act_head) {Action};
  \node[body, below=0cm of act_head] (act_body) {$L1=$ \textcolor{brown}{y}\\$L2=$ \textcolor{brown}{z}};
  
  \node[header, right=0.3cm of act_head] (C_head) {$C$};
  \node[body, below=0cm of C_head] (C_body) {$false=\textbf{x}$\\$true=?$ \textcolor{brown}{z}};
  
  \node[header, right=0.3cm of C_head] (SC_head) {Synthesize\\$C.code$};
  \node[body, below=0cm of SC_head] (SC_body) {$code=$ \textcolor{cyan}{X}};
  
  \node[header, minimum width=0.6cm, right=0.3cm of SC_head] (close) {)};
  
  \node[header, right=0.3cm of close] (S1_head) {$S_1$};
  \node[body, below=0cm of S1_head] (S1_body) {$next=?$ \textcolor{brown}{y}};

  
  \node[header, right=0.3cm of S1_head] (SS1_head) {Synthesize\\$S_1.code$};
  \node[body, below=0cm of SS1_head] (SS1_body) {$code=?$ \textcolor{orange}{Y}\\$Ccode=$ \textcolor{cyan}{X}\\$l1=$ \textcolor{brown}{y}\\$l2=$ \textcolor{brown}{z}};
  
  \node[header, right=0.3cm of SS1_head] (Final_head) {Synthesize\\$S.code$};
  \node[body, below=0cm of Final_head] (Final_body) {$code=?$\\data};
  \node[below=0.2cm of Final_body, font=\scriptsize] {actions};



  % --- RIQUADRI E COLLEGAMENTI (CODICE) ---
  % Spostati più in basso per non sovrapporsi
  
  \node[codeblock, below=1.5cm of while, anchor=north west, xshift=-1.5cm] (code_left) {
      $L1=new();$ \textcolor{magenta}{\checkmark}\\
      $L2=new();$ \textcolor{magenta}{\checkmark}\\
      $stack[top-1].true=L2;$ \textcolor{magenta}{\checkmark}\\
      $stack[top-4].next=L1;$ \textcolor{magenta}{\checkmark}\\
      $stack[top-5].l1=L1;$ \textcolor{magenta}{\checkmark}\\
      $stack[top-5].l2=L2;$ \textcolor{magenta}{\checkmark}
  };
  \draw[->, thick, bend right=30] (act_body.south) to (code_left.north east);

  \node[pinkbox, below=2cm of SC_body] (code_center) {
      $stack[top-3].Ccode = code;$
  };
  \draw[dotted, thick] (SC_body.south) -- (code_center.north);

  \node[pinkbox, below=2.5cm of SS1_body] (code_right) {
      $stack[top-1].code =$ \\
      \textbf{label} $||$ $l1$ $||$ $Ccode$ \textcolor{cyan}{X} \\
      $||$ \textbf{label} $||$ $l2$ $||$ $code;$ \textcolor{orange}{Y}
  };
  \draw[dotted, thick] (SS1_body.south) -- (code_right.north);

  % Freccia Arancione (da destra a sinistra sotto)
  \draw[->, thick, orange, looseness=0.8] (Final_head.east) to [out=0, in=0] (code_right.east);

  % --- ANNOTAZIONI ---

  % Nota a sinistra (spostata ancora più a sinistra)
  \node[note, left=1cm of while] (note_1) {richiede al\\parser di\\consumare\\il terminale\\e top passa\\al prossimo};
  \draw[->, thick, violet] (note_1.east) to [bend left] (while.west);
  

  % Crocette viola (sopra i blocchi)
  \foreach \n in {while, open, act_head, C_head, SC_head}
      \node[cross, above=0.2cm of \n] {$\times$};
  \node[cross, above=0.2cm of S1_head] {$\downarrow$};

  % Hp Induttiva (sopra, centrale)
  \node[note, text width=2cm, align=center] (hp) at (2, -1.5) {\textbf{Hp. Induttiva}\\usata per};
  \draw[->, thick, cyan] (hp) to [out=180, in=90] (C_head.north);
  \draw[->, thick, orange] (hp) to [out=0, in=90] (SS1_head.north);


  
  % Nota azzurra (sopra SS1)
  \node[note, text=cyan, above=1cm of S1_head, align=center] (note_blue) {una volta concluso C\\in $code=?$ ci sara'\\$code=C$};
  \draw[->, thick, cyan] (note_blue) to (SC_head.north);

\end{tikzpicture}
\caption{Diagramma dettagliato della gestione dello stack.}
\end{figure}



\subsection{Implementazione SDT con un Parser LR (Quarta Strategia)}

Per implementare SDT che hanno azioni interne (non postfisse) utilizzando un parser Bottom-Up (LR), è necessario adattare la grammatica.

La tecnica si divide in 3 passi:
\begin{enumerate}
    \item Si identificano le azioni interne prima di un NT per calcolare gli attributi ereditati e le azioni alla fine per calcolare gli attributi sintetizzati della testa.
    \item Si introduce un \textbf{Non-Terminale Marcatore (M)} per sostituire ogni azione interna.
    \item Se $M$ sostituisce un'azione $\alpha$ in una produzione A $\to$ $\alpha a \beta$, si associa a $M \to \epsilon$ l'azione a'.
\end{enumerate}

L'azione associata a $M$:
\begin{itemize}
    \item Copia come attributo ereditato di $M$ tutti gli attributi di A dei simbolo in $\alpha$ di cui l'azione a necessita.
    \item Calcola gli attributi nello stesso modo di a, ma li rende attributi sintetizzati di $M$.
\end{itemize}

\textbf{Proprietà fondamentale:} L'aggiunta di marcatori (che producono $\epsilon$) in qualsiasi posizione del corpo delle produzioni di una grammatica LL produce come risultato una nuova grammatica che appartiene alla classe LR.

\subsubsection*{Esempio di trasformazione}
Data la produzione con azione interna:
\[ A \to \{ B.i = f(A.i); \} B C \]
Si introduce il marcatore $M$:
\[ A \to M B C \]
\[ M \to \epsilon \quad \{ M.i = A.i; \ M.s = f(M.i); \} \]
Dove $M.s$ è l'attributo sintetizzato che porta fuori il valore calcolato.

\subsubsection*{Esempio Pratico: While con Parser LR}
Applicando i marcatori alla produzione del \texttt{while}:

\[ S \to \textbf{while } ( \ M \ C \ ) \ N \ S_1 \]

Dove $M$ e $N$ sono marcatori introdotti per gestire le azioni intermedie:
\begin{itemize}
    \item \textbf{M}: Si occupa di generare le etichette $L1, L2$ e settare $C.true, C.false$.
    \item \textbf{N}: Si occupa di settare $S_1.next$.
\end{itemize}

\subsubsection*{Gestione dello Stack LR}
Durante la riduzione, gli attributi si trovano in posizioni specifiche dello stack (ipotesi induttiva):
\begin{enumerate}
    \item $S.next$ si trova al di sotto del corpo della produzione (sotto il token \texttt{while}).
    \item $C.true$ e $C.false$ si trovano nel record di $M$, immediatamente sotto il record per $C$.
    \item $S1.next$ si troverà nel record di N, immediatamente sotto il record di S1.
    \item $C.code$ si trova nel record di $C$.
    \item $S.code$ si troverà nel record di $S$ alla fine della riduzione.
\end{enumerate}

Di seguito viene riportato il codice eseguito dal parser LR nelle tre fasi cruciali della traduzione: la preparazione delle etichette (marcatore $M$), il passaggio del flusso di controllo al corpo (marcatore $N$) e la sintesi finale del codice ($S$).

\subsection*{1. Codice eseguito durante la riduzione di $\epsilon \to M$}

Prima di analizzare la condizione $C$, il parser riduce la produzione vuota al marcatore $M$. In questo momento lo stack contiene \texttt{while}, \texttt{(} e il marcatore $M$ in cima.
Viene eseguito il seguente codice per preparare le etichette e propagare gli attributi:

\begin{verbatim}
L1 = new();                  // Genera etichetta per inizio controllo condizione
L2 = new();                  // Genera etichetta per inizio corpo del ciclo
C.true = L2;                 // Se C è vero, salta a L2
C.false = stack[top-3].next; // Se C è falso, salta a S.next (recuperato dallo stack)
\end{verbatim}

\textbf{Nota sull'offset:}
Il valore \texttt{stack[top-3].next} si riferisce all'attributo ereditato $S.next$.
Analisi della pila in questo momento ($M$ è la cima):
\begin{itemize}
    \item \texttt{top}: $M$
    \item \texttt{top-1}: \texttt{(}
    \item \texttt{top-2}: \texttt{while}
    \item \texttt{top-3}: record contenente $S.next$
\end{itemize}

\vspace{0.5cm}

\subsection*{2. Codice per il Marcatore $N$ (Calcolo di $S_1.next$)}

Quando il parser ha finito di analizzare $C$ e la parentesi chiusa, riduce $\epsilon$ a $N$. Il record di $N$ si trova ora sulla cima dello stack ($top$).
L'unico dato associato a $N$ è l'attributo ereditato $S_1.next$, che deve essere recuperato dal record di $M$ (dove è stato salvato $L1$).

Dato che lo stack contiene $M \ C \ ) \ N$, il record di $M$ si trova 3 posizioni sotto $N$.

\begin{verbatim}
// N è in cima (top). Recupera L1 da M (top-3)
S1.next = stack[top - 3].L1;
\end{verbatim}

\vspace{0.5cm}

\subsection*{3. Codice eseguito durante la riduzione finale di $S$}

A questo punto il parser ha riconosciuto l'intero corpo $S_1$ e riduce tutto ciò che si trova tra \texttt{while} e $S_1$ a $S$.
\[ S \to \textbf{while } ( \ M \ C \ ) \ N \ S_1 \]

Il codice recupera i frammenti generati dai marcatori e dai sotto-nodi (che si trovano ancora nello stack agli offset corretti rispetto a $S_1$ che è in cima), concatena le parti e aggiorna lo stack.

\begin{verbatim}
// Costruzione del codice intermedio (tempCode)
// M è a top-4, C è a top-3, S1 è a top
tempCode = label || stack[top - 4].L1 || stack[top - 3].code ||
           label || stack[top - 4].L2 || stack[top].code;

// Aggiornamento dello Stack
top = top - 6; //per arrivare al while

// Il codice viene salvato nel record di S (che ora è in cima)
stack[top].code = tempCode;
\end{verbatim}

