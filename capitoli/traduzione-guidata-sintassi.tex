\section{Traduzione guidata dalla sintassi}

Associando attributi ai simboli grammaticali, si definiscono valori tramite regole semantiche. La traduzione guidata dalla sintassi costruisce un albero di parsing per calcolare questi valori.

\subsection{Definizioni guidate dalla sintassi (SSD)}

È una grammatica context-free con l'aggiunta di attributi e regole semantiche. Gli attributi sono associati ai simboli della grammatica, le regole semantiche sono associate alle produzioni.

\textbf{Osservazione:} Dato un simbolo della grammatica \(X\) e uno dei suoi attributi \(a\), si indica \(X.a\) (il valore di a per uno specifico nodo dell'albero di parsing con etichetta X).

Una SSD che contiene solo attributi sintetizzati è detta \textbf{S-attribuita}, cioè dove ogni regola calcola un attributo associato alla variabile della parte sinistra della produzione mediante gli attributi associati ai simboli della parte destra. Una SSD senza effetti collaterali (qualcosa che modifica lo stato del sistema oltre a restituire un valore, tipo stampare a video) è detta \textbf{grammatica ad attributi}.

\subsection{Valutazione di una SSD ai nodi di un albero di parsing}

Un albero di parsing annotato mostra i valori degli attributi associati ai nodi.

Gli attributi ereditati sono utili quando la struttura dell'albero di parsing non corrisponde alla sintassi astratta del codice sorgente.

\subsubsection{Attributi sintetizzati}
Un attributo sintetizzato relativo ad un nodo \(N\) è definito unicamente in base ai figli di \(N\) e a \(N\) stesso.

\subsubsection{Attributi ereditati}
Un attributo ereditato relativo ad un nodo \(N\) è definito unicamente in base al padre di \(N\), a \(N\) stesso e ai fratelli di \(N\) (non dai figli).

\textbf{NB!} I terminali non possono avere attributi ereditati.

\subsection{Esempio: \(3 \times 5 \times 4\)}

\subsubsection{Prima grammatica}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to T * F\) \quad \(T.val = T.val \times F.val\)
    \item \(T \to F\) \quad \(T.val = F.val\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=2cm},
  level 3/.style={sibling distance=1.5cm}
]
\node {\(T.val =\)}
  child {node {\(T.val =\)}
    child {node {\(T.val\)}
      child {node {\(F.val\)}
        child {node {3}}
      }
    }
    child {node {*}}
    child {node {\(F.val\)}
      child {node {5}}
    }
  }
  child {node {*}}
  child {node {\(F.val\)}
    child {node {4}}
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, *, 5, *, 4

\subsubsection{Seconda grammatica (con attributi ereditati)}

\textbf{Produzioni e regole semantiche:}

\begin{enumerate}
    \item \(T \to FT'\) \quad \(T'.inh = F.val\) \quad \(T.val = T'.syn\)
    \item \(T' \to *FT'_1\) \quad \(T'_1.inh = T'.inh \times F.val\) \quad \(T'.syn = T'_1.syn\)
    \item \(T' \to \varepsilon\) \quad \(T'.syn = T'.inh\)
    \item \(F \to \text{num}\) \quad \(F.val = \text{num}.lexval\)
\end{enumerate}

\textbf{Albero di parsing annotato:}

\begin{center}
\begin{tikzpicture}[
  level distance=2.2cm,
  level 1/.style={sibling distance=7cm},
  level 2/.style={sibling distance=4.5cm},
  level 3/.style={sibling distance=3.5cm},
  level 4/.style={sibling distance=2.5cm},
  every node/.style={align=center, text width=4.5cm, font=\small}
]
\node {\(T.val = T'.syn(60)\)}
  child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(3)\)}
    child {node[text width=1cm] {3}}
  }
  child {node[text width=4cm] {\(T'.inh = F.val(3)\) \\ \(T'.syn = T'_1.syn(60)\)}
    child {node[text width=1cm] {*}}
    child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(5)\)}
      child {node[text width=1cm] {5}}
    }
    child {node[text width=4.5cm] {\(T'_1.inh =\) \\ \(T'.inh \times F.val(15)\) \\ \(T'_1.syn = T'_2.syn(60)\)}
      child {node[text width=1cm] {*}}
      child {node[text width=3cm] {\(F.val =\) \\ \(\text{num}.lexval(4)\)}
        child {node[text width=1cm] {4}}
      }
      child {node[text width=4.5cm] {\(T'_2.inh =\) \\ \(T'_1.inh \times F.val(60)\) \\ \(T'_2.syn = T'_2.inh(60)\)}
        child {node[text width=1.5cm] {\(\varepsilon\)}}
      }
    }
  };
\end{tikzpicture}
\end{center}

\textbf{Ordinamento di valutazione:} 3, 5, *, 4, \(\varepsilon\)

\textbf{Calcolo dei valori:}
\begin{itemize}
    \item \(F.val = 3\)
    \item \(T'.inh = 3\)
    \item \(F.val = 5\)
    \item \(T'_1.inh = 3 \times 5 = 15\)
    \item \(F.val = 4\)
    \item \(T'_2.inh = 15 \times 4 = 60\)
    \item \(T'_2.syn = 60\)
    \item \(T'_1.syn = 60\)
    \item \(T'.syn = 60\)
    \item \(T.val = 60\)
\end{itemize}



\subsection{Grafi delle dipendenze}

\subsubsection{Esempio: \(1 * 2\)}

\textbf{Produzioni e regole semantiche:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzione} & \textbf{Regole semantiche} \\
\hline
1) \(T \to FT'\) & \(T'.inh = F.val\) \\
 & \(T.val = T'.syn\) \\
\hline
2) \(T' \to * F T'_1\) & \(T'_1.inh = T'.inh \times F.val\) \\
 & \(T'.syn = T'_1.syn\) \\
\hline
3) \(T' \to \varepsilon\) & \(T'.syn = T'.inh\) \\
\hline
4) \(F \to \text{digit}\) & \(F.val = \text{digit}.lexval\) \\
\hline
\end{tabular}
\end{center}

\textbf{Grafo delle dipendenze:}

\begin{center}
\begin{tikzpicture}[
  node distance=1.5cm and 2cm,
  every node/.style={font=\footnotesize},
  arrow/.style={->, thick, >=stealth, dashed}
]

% Nodi disposti secondo l'immagine
\node (T9val) at (2,5) {\(T\) 9 \(val\)};
\node (F3val) at (-2,3.5) {\(F\) 3 \(val\)};
\node (inh5) at (2,3.5) {\(inh\) 5 \(T'\)};
\node (syn8) at (5,3.5) {8 \(syn\) \(T'\)};
\node (digit1) at (-2,2) {digit 1 \(lexval\)};
\node (star) at (0,2) {*};
\node (F4val) at (2,1.5) {\(F\) 4 \(val\)};
\node (inh6) at (4.5,1.5) {\(inh\) 6 \(T'\)};
\node (syn7) at (6.5,1.5) {7 \(syn\) \(T'\)};
\node (digit2) at (2,0) {digit 2 \(lexval\)};
\node (epsilon) at (4.5,0) {\(\varepsilon\)};

% Frecce come nell'immagine
% digit 1 -> F 3 val
\draw[arrow] (digit1) -- (F3val);

% F 3 val -> inh 5 T'
\draw[arrow] (F3val) to[out=0, in=180] (inh5);

% digit 2 -> F 4 val
\draw[arrow] (digit2) -- (F4val);

% F 4 val -> inh 6 T'
\draw[arrow] (F4val) -- (inh6);

% inh 5 T' -> inh 6 T' (curva)
\draw[arrow] (inh5) to[out=-20, in=150] (inh6);

% inh 6 T' -> syn 7 T' (arco sopra)
\draw[arrow] (inh6) to[out=60, in=120] (syn7);

% syn 7 T' -> syn 8 T'
\draw[arrow] (syn7) to[out=150, in=0] (syn8);

% syn 8 T' -> T 9 val (curva a destra)
\draw[arrow] (syn8) to[out=90, in=0] (T9val);

\end{tikzpicture}
\end{center}


\subsection{Ordinamento topologico}

Gli ordinamenti validi sono costituiti da sequenze \(N_1, N_2, \ldots, N_k\), tale che se esiste un arco dal nodo \(N_i\) al nodo \(N_j\) nel grafo delle dipendenze, allora deve essere \(i < j\).

\subsection{Grammatiche S-attribuite}

Una definizione guidata dalla sintassi è S-attribuita se e solo se ogni suo attributo è sintetizzato.

\subsection{Grammatiche L-attribuite}

Una definizione è L-attribuita se, nel grafo delle dipendenze, gli archi vanno solo da sinistra a destra. In particolare:
\begin{itemize}
    \item Gli attributi ereditati possono dipendere solo da attributi (ereditati o sintetizzati) dei simboli alla loro \textbf{sinistra} o da attributi ereditati del padre.
    \item Questo vincolo è necessario per evitare cicli e permettere la valutazione in una sola passata.
\end{itemize}

\paragraph{Effetti Controllati}
Non sempre le pure regole semantiche bastano. Spesso si introducono \textbf{effetti controllati} (es. \texttt{print}, aggiornamento della Symbol Table).
\begin{itemize}
    \item Questi effetti sono permessi in modo che la traduzione risulti corretta per qualsiasi ordinamento di valutazione valido.
    \item I vincoli di ordine imposti dagli effetti laterali vengono trattati come \textbf{archi impliciti} nel grafo delle dipendenze.
\end{itemize}

\subsection{Alberi sintattici}
È utile trasformare una stringa in ingresso in un albero che ne rappresenta la struttura gerarchica (albero sintattico) per facilitare le fasi successive della compilazione.

\subsection{Classi di SDT implementabili durante il parsing}
Esistono due classi principali di SDT che consentono l'implementazione della traduzione direttamente durante l'analisi sintattica:

\begin{enumerate}
    \item La grammatica sottostante può essere riconosciuta da un parser \textbf{LR} e la SDD è \textbf{S-attribuita} (approccio \textit{bottom-up}).
    \item La grammatica sottostante può essere riconosciuta da un parser \textbf{LL} e la SDD è \textbf{L-attribuita} (approccio \textit{top-down}).
\end{enumerate}

\subsubsection{Marcatori e proprietà}
Per gestire azioni semantiche in posizioni arbitrarie, si possono introdurre dei marcatori (non-terminali che producono $\epsilon$).

\textbf{Proprietà:} Se la grammatica arricchita con i marcatori può essere trattata da un dato metodo di parsing, allora lo SDT corrispondente può essere implementato durante il parsing stesso.

\subsection{SDT postfissi}
Un SDT si dice \textbf{postfisso} se, in ogni produzione, le azioni semantiche sono posizionate esclusivamente \textbf{alla fine} del corpo della produzione.
\[ A \to X Y Z \{ \text{azione} \} \]
Questi schemi sono ideali per l'implementazione durante il parsing bottom-up.
\subsubsection{Schema di traduzione postfisso - Calcolatrice}

\textbf{Produzioni, Regole sintattiche e SDT:}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Produzioni} & \textbf{Regole sintattiche} & \textbf{SDT} \\
\hline
\(L \to E\) \textbf{n} & \{\texttt{print}(\(E.val\))\} & \{\texttt{print}(\(E.val\))\} \\
\hline
\(E \to E + T\) & \{\(E.val = E_1.val + T.val\)\} & \{\(E.val = E_1.val + T.val\)\} \\
\hline
\(E \to T\) & \{\(E.val = T.val\)\} & \{\(E.val = T.val\)\} \\
\hline
\(T \to T * F\) & \{\(T.val = T_1.val \times F.val\)\} & \{\(T.val = T_1.val \times F.val\)\} \\
\hline
\(T \to F\) & \{\(T.val = F.val\)\} & \{\(T.val = F.val\)\} \\
\hline
\(F \to (E)\) & \{\(F.val = E.val\)\} & \{\(F.val = E.val\)\} \\
\hline
\(F \to \textbf{digit}\) & \{\(F.val = \textbf{digit}.lexval\)\} & \{\(F.val = \textbf{digit}.lexval\)\} \\
\hline
\end{tabular}
\end{center}

\subsection{Stack del parser con attributi}

\textbf{Rappresentazione dello stack:}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
 & \(XYZ\) & \\
\hline
 & \(X.x\) \(Y.y\) \(Z.z\) & \\
\hline
\multicolumn{3}{c}{\(\uparrow\)} \\
\multicolumn{3}{c}{top} \\
\end{tabular}
\end{center}

Dopo una riduzione \(A \to XYZ\):

\begin{center}
\begin{tabular}{|c|}
\hline
\(A\) \\
\hline
\(A.a\) \\
\hline
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}

Dove \(A.a = f(X.x, Y.y, Z.z)\)

\subsection{Implementazione con manipolazione dello stack}

\textbf{Azioni con manipolazione esplicita dello stack:}

\begin{itemize}
    \item \(L \to E\) \textbf{n}: \{\texttt{print}(\(stack[top-1].val\)); \(top = top - 1\)\}
    \item \(E \to E + T\): \{\(E.val = E.val + T.val\)\}
    \item \(T \to T * F\): \{\(stack[top-2].val = stack[top-2].val \times stack[top].val\); \(top = top - 2\)\}
    \item \(F \to (E)\): \{\(stack[top-2].val = stack[top-1].val\); \(top = top - 2\)\}
\end{itemize}

\subsection{Esempio di parsing: \(3 * (5 + 2)\) \textbf{n}}

\textbf{Sequenza di parsing con lo stack:}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
& \(F\) & \(E\) & \(T\) & \(E+T\) & \(T*F\) & (\(E\)) & & \\
\hline
& \(\uparrow\) & & & & & & & \\
\hline
3 & * & ( & 5 & + & 2 & ) & \textbf{n} & \texttt{print} \\
\hline
\end{tabular}
\end{center}

\textbf{Evoluzione dello stack:}

\begin{itemize}
    \item Dopo applicazione di \(F \to (E)\): \(top\) viene decrementato
    \item Dopo riduzione: i valori vengono calcolati e memorizzati nella posizione corretta dello stack
\end{itemize}

\textbf{Posizioni dello stack durante il parsing:}

\begin{center}
\begin{tabular}{c}
top-2 \\
\(\uparrow\) \\
top-1 \\
\(\uparrow\) \\
top \\
\end{tabular}
\end{center}





\subsection{Schemi di traduzione con azioni interne alle produzioni}

\subsubsection{Definizione e comportamento}

Un'azione può essere inserita in qualsiasi posizione nel corpo di una produzione. Essa sarà eseguita non appena tutti i simboli grammaticali alla sua sinistra saranno stati consumati.

Quindi, in una produzione del tipo \(B \to X \{a\} Y\), l'azione \(a\) è eseguita non appena abbiamo riconosciuto \(X\), se \(X\) è un terminale, oppure tutti i terminali derivati da \(X\), se quest'ultimo è un non-terminale.

\textbf{Comportamento nel parsing:}

\begin{itemize}
    \item Nel parsing \textbf{bottom-up}: si esegue l'azione \(a\) non appena l'occorrenza in esame del simbolo \(X\) appare sulla cima dello stack
    \item Nel parsing \textbf{top-down}: si esegue l'azione \(a\) immediatamente prima di tentare l'espansione di \(Y\), se \(Y\) è un non-terminale, oppure prima di cercare \(Y\) in ingresso, se \(Y\) è un terminale
\end{itemize}

\subsection{Eliminazione della ricorsione sinistra dagli SDT}

\subsubsection{Motivazione e principi}

Poiché nessuna grammatica che presenti ricorsione sinistra può essere analizzata mediante parsing top-down, diventa fondamentale eliminare tale tipo di ricorsione.

Quando una grammatica è L-attribuita e la si trasforma per eliminare la ricorsione sinistra, dobbiamo gestire correttamente le azioni semantiche.

\textbf{Assunzione:} Le azioni semantiche non calcolano valori di attributi ma effettuano azioni sulle stringhe di simboli terminali.

\textbf{Principio:} Nel processo di trasformazione della grammatica, le azioni semantiche sono trattate come ulteriori simboli terminali.

\subsubsection{Trasformazione standard}

Le trasformazioni della grammatica preservano l'ordine dei terminali nella stringa generata. La strategia consiste nel sostituire produzioni della forma:
\[
A \to A\alpha \mid \beta
\]
con nuove produzioni usando un nuovo non-terminale \(R\):
\[
A \to \beta R
\]
\[
R \to \alpha R \mid \varepsilon
\]

\subsubsection{Trasformazione per SDD S-attribuite}

Per una singola produzione ricorsiva, una singola produzione non-ricorsiva, ed un singolo attributo del non-terminale ricorsivo sinistro.

\textbf{Grammatica originale con ricorsione sinistra:}

\begin{itemize}
    \item \(A \to A\alpha\) con azione \(\{A.a = g(A_1.a, \alpha.y)\}\)
    \item \(A \to X\) con azione \(\{A.a = f(X.x)\}\)
\end{itemize}

\textbf{Grammatica trasformata senza ricorsione sinistra:}

\begin{itemize}
    \item \(A \to X\) \(\{R.i = f(X.x)\}\) \(R\) \(\{A.a = R.s\}\)
    \item \(R \to \alpha\) \(\{R_1.i = g(R.i, \alpha.y)\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
\end{itemize}

Dove \(R.i\) è l'attributo ereditato e \(R.s\) è l'attributo sintetizzato di \(R\).

\subsubsection{Esempio - Eliminazione ricorsione nelle espressioni}

Si considerino le seguenti produzioni relative a \(E\), prese da uno SDT per la traduzione di espressioni dalla forma infissa alla forma postfissa.

\textbf{SDT con ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Produzioni} & \textbf{Azioni semantiche} \\
\hline
\(E \to E_1 + T\) & \(\{\text{print}('+');\}\) \\
\hline
\(E \to T\) & \\
\hline
\end{tabular}
\end{center}

\noindent Se applichiamo la trasformazione standard al non-terminale \(E\), identifichiamo le parti $\alpha$ (la parte ricorsiva) e $\beta$ (la base) trattando l'azione semantica come un simbolo terminale:

\begin{itemize}
    \item Il \textbf{resto della produzione ricorsiva sinistra} ($\alpha$) è:
    \[ \alpha = + T \; \{ \text{print}('+'); \} \]
    \item Il \textbf{corpo dell'altra produzione} ($\beta$) è:
    \[ \beta = T \]
\end{itemize}

Introducendo il nuovo non-terminale \(R\) (che rappresenta il resto), si applica la regola \(E \to \beta R\) e \(R \to \alpha R \mid \varepsilon\), ottenendo:

\textbf{SDT senza ricorsione sinistra:}

\begin{center}
\begin{tabular}{|l|}
\hline
\textbf{Produzioni risultanti} \\
\hline
\(E \to T R\) \\
\hline
\(R \to + T\) \(\{\text{print}('+');\}\) \(R\) \\
\hline
\(R \to \varepsilon\) \\
\hline
\end{tabular}
\end{center}

\subsubsection{Esempio completo - Calcolatrice da tavolo}

\textbf{Con ricorsione sinistra:}

\begin{itemize}
    \item \(E \to E_1 + T\) \(\{E.v = E_1.v + T.v\}\)
    \item \(E \to T\) \(\{E.v = T.v\}\)
    \item \(T \to T_1 \times F\) \(\{T.v = T_1.v \times F.v\}\)
    \item \(T \to F\) \(\{T.v = F.v\}\)
    \item \(F \to (E)\) \(\{F.v = E.v\}\)
    \item \(F \to \textbf{digit}\) \(\{F.v = \textbf{digit}.\text{lexval}\}\)
\end{itemize}

\textbf{Senza ricorsione sinistra:}

\begin{itemize}
    \item \(E \to T\) \(\{R.i = T.v\}\) \(R\) \(\{E.v = R.s\}\)
    \item \(R \to + T\) \(\{R_1.i = R.i + T.v\}\) \(R_1\) \(\{R.s = R_1.s\}\)
    \item \(R \to \varepsilon\) \(\{R.s = R.i\}\)
    \item \(T \to F\) \(\{X.i = F.v\}\) \(X\) \(\{T.v = X.s\}\)
    \item \(X \to \times F\) \(\{X_1.i = X.i \times F.v\}\) \(X_1\) \(\{X.s = X_1.s\}\)
    \item \(X \to \varepsilon\) \(\{X.s = X.i\}\)
\end{itemize}

\subsection{Procedure generali per SDT}

\subsubsection{Procedura in tre passi}

\begin{enumerate}
    \item Si costruisce l'albero di parsing, ignorando le azioni semantiche
    \item Si esamina ogni nodo interno \(N\) con produzione associata. Si aggiungono nuovi nodi figli di \(N\) corrispondenti alle azioni, in modo che scorrendo tutti i figli di \(N\) da sinistra a destra si abbiano esattamente gli stessi simboli e le stesse azioni semantiche
    \item Si visita l'albero in preordine e non appena si incontra un nodo annotato con un'azione la si esegue
\end{enumerate}

\subsubsection{Esempio con albero di parsing}

Per l'espressione \(3 \times 5 + 4\), l'output in notazione prefissa è: \(+ (\times 3 \ 5) \ 4\)

Le azioni \(\{\text{print}('+');\}\) e \(\{\text{print}('*');\}\) vengono eseguite visitando l'albero in preordine, stampando gli operatori prima degli operandi.


L'albero rappresenta il parsing dell'espressione \(3 \times 5 + 4\) con le azioni di stampa in notazione prefissa.

\begin{center}
\begin{tikzpicture}[
  level distance=1.6cm,
  level 1/.style={sibling distance=5cm},
  level 2/.style={sibling distance=3.5cm},
  level 3/.style={sibling distance=2.8cm},
  level 4/.style={sibling distance=2cm},
  level 5/.style={sibling distance=1.5cm},
  every node/.style={align=center, font=\small},
  action/.style={fill=yellow!40, rectangle, rounded corners, inner sep=3pt, font=\footnotesize}
]

\node (L) {\(L\)}
  child {node (E1) {\(E\)}
    child {node (E2) {\(E\)}
      child {node (T1) {\(T\)}
        child {node (T2) {\(T\)}
          child {node (F1) {\(F\)}
            child {node (d1) {digit}
              child {node[action] (a3) {\{\text{print}(3);\}}}
            }
          }
        }
        child {node (star) {*}}
        child {node (F2) {\(F\)}
          child {node (d2) {digit}
            child {node[action] (a5) {\{\text{print}(5);\}}}
          }
        }
      }
      child {node (plus) {+}}
      child {node (T3) {\(T\)}
        child {node (F3) {\(F\)}
          child {node (d3) {digit}
            child {node[action] (a4) {\{\text{print}(4);\}}}
          }
        }
      }
    }
    child {node (n) {\textbf{n}}}
  };

% Azioni semantiche con linee tratteggiate
\node[action, left=2cm of E2] (print_plus) {\{\text{print}('+');\}};
\node[action, left=2cm of T2] (print_star) {\{\text{print}('*');\}};

% Linee tratteggiate che collegano le azioni ai nodi
\draw[dashed, gray, thick] (print_plus) -- (E2);
\draw[dashed, gray, thick] (print_star) -- (T1);

\end{tikzpicture}
\end{center}

\textbf{Output in notazione prefissa:} + * 3 5 4

\textbf{Ordine di esecuzione delle azioni:}
\begin{enumerate}
    \item print('+')
    \item print('*')
    \item print(3)
    \item print(5)
    \item print(4)
\end{enumerate}

%lezione 20 novembre
\subsection{Trasformazione da SDD L-attribuita a SDT}
Regole per trasformare SDD $\to$ SDT per parsing Top-Down:

\begin{enumerate}
    \item \textbf{Azioni per Attributi Ereditati:} Si aggiungono le azioni che calcolano gli attributi ereditati di un non-terminale $A$ \textbf{immediatamente prima} dell'occorrenza di $A$ nel corpo della produzione.
    \item \textbf{Azioni per Attributi Sintetizzati:} Si aggiungono le azioni che calcolano un attributo sintetizzato relativo alla testa della produzione \textbf{alla fine} del corpo di quella produzione.
\end{enumerate}

\section*{Esempio: Traduzione dello Statement \texttt{while}}
Consideriamo la produzione:
\[ S \to \mathbf{while} \ (C) \ S_1 \]

Useremo i seguenti attributi per generare il codice intermedio richiesto:

\begin{enumerate}
    \item L'attributo \textbf{ereditato} $S.next$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito dopo che $S$ è terminato.
    
    \item L'attributo \textbf{sintetizzato} $S.code$ è la porzione di codice intermedio che implementa uno statement $S$ e termina con un salto a $S.next$ (se necessario, o cade nel flusso successivo).
    
    \item L'attributo \textbf{ereditato} $C.true$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito se $C$ risulta vera.
    
    \item L'attributo \textbf{ereditato} $C.false$ indica l'etichetta relativa all'inizio del codice che deve essere eseguito se $C$ risulta falsa.
    
    \item L'attributo \textbf{sintetizzato} $C.code$ rappresenta la porzione di codice intermedio che implementa la condizione $C$ e che salta a $C.true$ oppure $C.false$ a seconda del valore dell'espressione $C$.
\end{enumerate}

\subsection*{Regole Semantiche (SDD)}
Per generare le nuove etichette e definire il flusso, si applicano le seguenti regole:

\begin{align*}
& L1 = \text{new}(); \quad \text{(Genera etichetta inizio ciclo)} \\
& L2 = \text{new}(); \quad \text{(Genera etichetta inizio corpo)} \\
& S_1.next = L1; \quad \text{(Dopo il corpo, torna a valutare la condizione)} \\
& C.false = S.next; \quad \text{(Se falso, esce dal ciclo)} \\
& C.true = L2; \quad \text{(Se vero, esegue il corpo)} \\
& S.code = \textbf{label} \ || \ L1 \ || \ C.code \ || \ \textbf{label} \ || \ L2 \ || \ S_1.code
\end{align*}

\subsection*{Logica del Flusso di Controllo}
Il funzionamento del codice generato segue questo schema logico (rappresentazione del diagramma):

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[
      node distance=3.5cm, % Aumentata la distanza orizzontale
      box/.style={
          draw, 
          minimum width=1.5cm, 
          minimum height=1cm, 
          align=center, 
          font=\large\bfseries
      },
      arrow/.style={
          ->, 
          >=Stealth, 
          thick,
          rounded corners=5pt
      }
  ]

  % --- 1. DEFINIZIONE DEI NODI ---
  
  % Nodo C (Condizione)
  \node[box] (C) {C};
  
  % Nodo S1 (Statement) - Posizionato più lontano per leggibilità
  \node[box, right=of C] (S1) {S\textsubscript{1}};

  % --- 2. COORDINATE PER IL BOX ESTERNO (S) ---
  % Calcolo coordinate per fare il rettangolo arancione grande abbastanza
  \coordinate (TopLeft) at ($(C.north west) + (-2, 2.5)$);
  \coordinate (BottomRight) at ($(S1.south east) + (2, -2)$);
  \coordinate (ExitPoint) at ($(BottomRight) + (0, 0.5)$); % Punto di uscita fittizio a destra

  % Disegno il box S (sfondo)
  \draw[orange!80!yellow, thick] (TopLeft) rectangle (BottomRight);
  
  % Etichetta grande "S" (spostata in basso a sinistra per non disturbare)
  \node[font=\Huge\bfseries\sffamily, orange!40!yellow, anchor=south west] 
      at ($(TopLeft |- BottomRight) + (0.2, 0.2)$) {S};

  % --- 3. FRECCE E FLUSSO ---

  % Ingresso L
  \draw[arrow, black] ($(C.west) - (1.5, 0)$) -- node[above] {L\textsubscript{1}} (C.west);
  \draw[arrow, orange!80!yellow, thick] ($(TopLeft |- C) + (-1, 0.5)$) -- node[above, black] {L} ($(TopLeft |- C) + (0.5, 0.5)$);

  % Percorso TRUE (Centrale)
  \draw[arrow, cyan, thick] (C.east) -- 
      node[above, text=black, yshift=2pt] {TRUE} 
      node[below, text=black] {L\textsubscript{2}} 
      (S1.west);
  
  % Nota sopra il percorso True
  \node[font=\small\sffamily, align=center] at ($(C)!0.5!(S1) + (0, 0.8)$) {Eseguo 1\textdegree{} istruzione};

  % Percorso LOOP (Ritorno da S1 a C) - Alto
  \draw[arrow, cyan, thick] (S1.north) -- ++(0, 1) coordinate(midup)
      -- ($(C.north) + (0, 1)$) 
      node[midway, above, text width=5cm, align=center, black] {Devo rifare controllo\\condizione} 
      -- (C.north);

  % Percorso FALSE (Uscita) - Basso
  \draw[arrow, green!60!black, thick] (C.south) 
      to[out=-90, in=180] ($(S1.south) + (0, -1)$) 
      -- (ExitPoint |- S1.south) 
      -- ++(1,0) node[right, black] {NEXT};
      
  \node[below right, font=\small] at (C.south east) {FALSE};

  \end{tikzpicture}
  \caption{Flusso di controllo del ciclo While.}
\end{figure}

\textbf{Spiegazione del diagramma:}
\begin{itemize}
    \item Il flusso entra nell'etichetta $L1$ (inizio del \texttt{while}).
    \item Viene valutata la condizione $C$.
    \item Se $C$ è \textbf{TRUE}, si va all'etichetta $L2$, si esegue lo statement $S_1$ e, al termine di $S_1$, il flusso deve tornare indietro a $L1$ per rivalutare la condizione.
    \item Se $C$ è \textbf{FALSE}, il flusso salta direttamente all'uscita ($S.next$ o NEXT).
\end{itemize}

\subsection*{Schema di Traduzione (SDT)}
Inserendo le azioni semantiche all'interno della produzione per supportare la generazione durante il parsing (anche top-down), otteniamo:

\begin{verbatim}
S -> while (
    { L1 = new(); L2 = new(); C.false = S.next; C.true = L2; }
    C )
    { S1.next = L1; }
    S1
    { S.code = label || L1 || C.code || label || L2 || S1.code; }
\end{verbatim}

In questo modo, le etichette $L1$ e $L2$ vengono generate prima di analizzare la condizione, e l'attributo $S_1.next$ viene impostato correttamente prima di analizzare il corpo $S_1$.

\subsection{Implementazione di SDD L-attribute}

I seguenti sono metodi che realizzano la traduzione durante la visita di un albero di parsing

\begin{itemize}
    \item \textbf{Traduzione durante la visita di un albero di parsing:}
    \begin{enumerate}
        \item Costruzione di un albero di parsing annotato (funziona per qualsiasi SDD non circolare).
        \item Costruzione dell'albero, aggiunta delle azioni e loro esecuzione in pre-ordine.
    \end{enumerate}
    \textit{Nota:} Questo approcci hanno un costo computazionale elevato (costruzione dell'albero).

    \item \textbf{Metodi di traduzione durante il parsing:}
    \begin{enumerate}
        \item Utilizzo di un parser a discesa ricorsiva con una funzione per ogni non-terminale.
        \item Generazione del codice al volo (On-the-fly), utilizzando un parser a discesa ricorsiva.
        \item Implementazione di uno SDT insieme a un parser LL.
        \item Implementazione di uno SDT insieme a un parser LR.
    \end{enumerate}
\end{itemize}

\subsubsection{Traduzione durante il parsing a discesa ricorsiva}
Un parser a discesa ricorsiva prevede una funzione A() per ogni non-terminale A della grammatica. È possibile estendere un tale parser
e trasformarlo in un traduttore facendo in modo che:
\begin{itemize}
    \item Gli argomenti della funzione $A()$ siano gli \textbf{attributi ereditati} del simbolo non-terminale $A$.
    \item Il valore restituito da $A()$ sia l'insieme degli \textbf{attributi sintetizzati} del simbolo $A$.
\end{itemize}

Il corpo della funzione deve occuparsi sia del parsing che della gestione degli attributi, in particolare la funzione deve:
\begin{enumerate}
    \item Decidere quale produzione utilizzare per espandere $A$.
    \item Verificare che ogni simbolo terminale appaia in ingresso quando richiesto; in quanto segue assumeremo che non sia necessario effettuare backtracking.
    \item Conservare in variabili locali i valori degli attributi necessari per il calcolo degli attributi ereditati relativi ai non-terminali nel corpo della produzione e/o
    degli attributi ereditati relativi al non-terminale alla testa della produzione.
    \item Chiamare le funzioni corrispondenti ai non-terminali nel corpo della produzione, passando gli argomenti corretti (ereditati) e salvando i risultati (sintetizzati).
\end{enumerate}

\subsubsection{Esempio: Implementazione \texttt{while} con ritorno di stringa}
\begin{lstlisting}[caption={Pseudocodice per la traduzione del while}]
  string S(label next) {
      string Scode, Ccode; /* variabili locali per frammenti di codice */
      label L1, L2;        /* etichette locali */
        
      if (il simbolo_corrente è il token WHILE) {
        
          avanza il puntatore di ingresso;
            
          verifica che '(' sia il prossimo simbolo, quindi avanza;
            
          L1 = new(); // Etichetta inizio controllo condizione
          L2 = new(); // Etichetta inizio corpo del ciclo
            
          Ccode = C(next, L2); 
            
          verifica che ')' sia il prossimo simbolo, quindi avanza;
            
          Scode = S(L1); 
            
          // Costruzione dell'attributo sintetizzato finale
          return ("label" || L1 || Ccode || "label" || L2 || Scode);
      }
      else { 
          /* gestione altri tipi di statement */ 
      }
  }
  \end{lstlisting}

  \subsection{Esempio Pratico: Parser a Discesa Ricorsiva per Espressioni}
  Di seguito è riportato il codice (pseudocodice C-like) per un parser che gestisce espressioni aritmetiche con eliminazione della ricorsione sinistra e gestione degli attributi.
  
  \textbf{Grammatica di riferimento (dopo eliminazione ricorsione sinistra):}
  \begin{align*}
  E &\to T \{ R.i = T.v \} R \{ E.v = R.s \} \\
  R &\to + T \{ R_1.i = R.i + T.v \} R_1 \{ R.s = R_1.s \} \mid \epsilon \{ R.s = R.i \} \\
  T &\to F \{ X.i = F.v \} X \{ T.v = X.s \} \\
  X &\to * F \{ X_1.i = X.i * F.v \} X_1 \{ X.s = X_1.s \} \mid \epsilon \{ X.s = X.i \} \\
  F &\to ( E ) \{ F.v = E.v \} \mid d \{ F.v = d.lexval \}
  \end{align*}
  
  \textbf{Implementazione delle funzioni:}
  
  \begin{lstlisting}
  // Gestione Produzione E -> T R
  int E() {
      int v_i, ev;
      // FIRST(T R) include FIRST(F) = { (, d }
      if (lookahead in { '(', 'd' }) {
          v_i = T();       // Calcola T.val
          ev = R(v_i);     // Passa T.val come ereditato a R
          return ev;       // Ritorna attributo sintetizzato
      } else {
          error();
      }
  }
  
  // Gestione Produzione T -> F X
  int T() {
      int x_i, tv;
      if (lookahead in { '(', 'd' }) {
          x_i = F();       // Calcola F.val
          tv = X(x_i);     // Passa F.val come ereditato a X
          return tv;
      } else {
          error();
      }
  }
  
  // Gestione Produzione R -> + T R1 | epsilon
  int R(int v_i) {
      int v_if, vs, tv;
      if (lookahead == '+') {
          match('+');
          tv = T();           // Calcola valore del termine successivo
          v_if = v_i + tv;    // Calcola nuovo ereditato: somma parziale
          vs = R(v_if);       // Ricorsione
          return vs;
      } 
      // Gestione produzione epsilon (FOLLOW(R) include ')', '$')
      else if (lookahead in { ')', '$' }) {
          return v_i;         // Ritorna il valore accumulato finora
      } else {
          error();
      }
  }
  
  // Gestione Produzione X -> * F X1 | epsilon
  int X(int x_i) {
      int x_1i, xs, fv;
      if (lookahead == '*') {
          match('*');
          fv = F();           // Calcola valore del fattore
          x_1i = x_i * fv;    // Calcola nuovo ereditato: prodotto parziale
          xs = X(x_1i);       // Ricorsione
          return xs;
      }
      // Gestione produzione epsilon (FOLLOW(X) include '+', ')', '$')
      else if (lookahead in { '+', ')', '$' }) {
          return x_i;
      } else {
          error();
      }
  }
  
  // Gestione Produzione F -> ( E ) | d
  int F() {
      int fv;
      if (lookahead == '(') {
          match('(');
          fv = E();
          match(')');
          return fv;
      } 
      else if (lookahead == 'd') {
          fv = lexval; // Valore del numero
          match('d');
          return fv;
      } else {
          error();
      }
  }
  \end{lstlisting}
  

  \subsubsection{Generazione del codice al volo}

  In molti casi comuni, tra cui il nostro esempio di generazione del codice del costrutto \texttt{while}, è possibile costruire incrementalmente porzioni di codice e memorizzarle in un array o in un file mediante opportune azioni dello SDT. Per fare ciò, le seguenti condizioni devono essere soddisfatte:
  
  \begin{enumerate}
      \item Per uno o più non-terminali esiste un attributo \textit{principale}. Per semplicità assumeremo che gli attributi principali siano tutti di tipo stringa.
      
      \item Gli attributi principali sono sintetizzati.
      
      \item Le regole per la valutazione degli attributi principali garantiscono che:
      \begin{enumerate}
          \item[(a)] l'attributo principale è dato dal concatenamento degli attributi principali dei non-terminali che appaiono nel corpo della produzione più, eventualmente, altri elementi che non sono attributi principali;
          
          \item[(b)] gli attributi principali dei non-terminali appaiono nella regola nello stesso ordine in cui i non-terminali appaiono nel corpo della produzione.
      \end{enumerate}
  \end{enumerate}
  
  Tali condizioni implicano che l'attributo principale può essere costruito emettendo solamente gli elementi del concatenamento che non sono attributi principali.

\subsubsection{Esempio: Statement While}
Possiamo modificare la funzione in modo che emetta gli elementi dell'attributo principale $S.code$ invece di salvarli per poi concatenarli nel valore di $S.code$ che verrà poi restituito.

Le funzioni $S()$ e $C()$ non restituiscono alcun valore, poiché tutti i loro attributi sintetizzati sono prodotti mediante stampa. Inoltre, la posizione delle istruzioni di stampa nella funzione è importante. L'ordine in cui i vari elementi vengono stampati è il seguente: per prima cosa la stringa ``label'' $L1$, quindi il codice relativo al non-terminale $C$, la stringa ``label'' $L2$, e infine il codice derivante dalla chiamata ricorsiva della funzione $S()$ .

\textbf{Codice con generazione al volo (pseudocodice):}

\begin{lstlisting}
void S(label next) {
    label L1, L2; /* etichette locali */
    if (simbolo_corrente è il token WHILE) {
        avanza il puntatore di ingresso;
        verifica che '(' sia il prossimo simbolo, quindi avanza;
        
        L1 = new(); 
        L2 = new();
        
        print("label", L1); // Stampa immediata
        
        // C gestisce i salti: true -> L2 (corpo), false -> next (uscita)
        C(next, L2); 
        
        verifica che '(' sia il prossimo simbolo, quindi avanza;
        
        print("label", L2); // Stampa etichetta corpo
        
        S(L1); // Chiamata ricorsiva per il corpo, torna a L1 dopo esec.
    }
    else { /* altri statement */ }
}
\end{lstlisting}

\subsection{Trasformazione SDD L-attribuita su grammatica LL a SDT azioni interne alle produzioni}
Supponiamo che una SDD L-attribuita sia basata su una grammatica LL e che sia stata convertita in uno SDT in cui le azioni si trovano all'interno delle produzioni. Possiamo effettuare la traduzione durante il parsing LL a patto di estendere lo stack del parser in modo da poter contenere \textbf{diversi tipi di record}.

Oltre ai record che rappresentano i terminali e i non-terminali della grammatica, lo stack del parser conterrà:
\begin{itemize}
    \item \textbf{action-record}: cioè record che contengono puntatori ad azioni che devono essere eseguite, e anche copie di attributi.
    \item \textbf{synthesize-record}: ovvero record destinati a salvare gli attributi sintetizzati dei non-terminali. Possono contenere azioni il cui scopo, in ordine, è copiare gli attributi sintetici più in basso nello stack in altri record.
\end{itemize}

Per gestire gli attributi sullo stack ci baseremo sui seguenti principi:

\begin{itemize}
    \item Gli attributi \textbf{ereditati} di un non-terminale $A$ sono memorizzati sullo stack, nel record che rappresenta il non-terminale. Il codice necessario per la valutazione di tali attributi è in genere rappresentato mediante un \textit{action-record} memorizzato sullo stack, immediatamente al di sopra del record che rappresenta $A$.
    
    \item Gli attributi \textbf{sintetizzati} relativi al non-terminale $A$ sono memorizzati in un \textit{synthesize-record} separato e posizionato sullo stack immediatamente al di sotto del record relativo ad $A$.
\end{itemize}


